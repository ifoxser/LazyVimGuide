# [第一章：介绍与安装](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-1/#_introduction_and_installation)

这本书是为那些被模态编辑强大功能所吸引，却因为即便是入门教程中也充斥着大量配置内容而感到望而生畏或索然无味的开发者们所写。

我猜你可能是一位 Visual Studio Code 用户（这确实是一个很棒的编辑器，我也用过几年），当然你也可能是从其他各种集成开发环境和代码编辑器转向模态编辑的。你可能听说过 Vim，现在想要尝试一下。

## [1.1. 为什么选择 Vim](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-1/#_why_vim)

Vim 有着非常悠久的历史。它创建于90年代早期，是对（更加）古老的 Vi 编辑器（创建于70年代）的改进。"Vim" 这个名字实际上是 "Vi, improved"（Vi的改进版）的缩写。而它的前身 Vi，则是 "Visual"（可视化）的简称，因为它是对更早期（1971年）的一个名为 ed 的非可视化行编辑器的改进。

> 有趣的是，ed 这个编辑器在现代 Unix 系统中仍然可用。如果你使用 MacOS 或 Linux 环境，你很可能可以在任何终端中输入 ed 来访问它。（如果你不小心尝试了的话，按 Control-D 可以退出）。现在你对 ed 的了解和我一样多了，相信我，你也不会想知道更多了。

你可能还熟悉 ed 的另一个分支版本：sed（流编辑器）。直到今天，它仍然被用于在 shell 管道中修改文本。

ed 命令还被扩展出了另一个行编辑器，叫做 ex，这个编辑器现在基本不再单独使用了，但它作为 Vim 的一个子模式被（广泛地）使用着。事实上，如果你安装了 Neovim 并在命令行中输入 ex，你会得到一个功能非常受限的 Neovim 实例，它只支持 ex 命令。

这确实是一个相当复杂的家族树，但仅凭血统并不能很好地预示质量，正如任何第四代显贵都能证明的那样。

使用任何一个编辑器都有很多原因，但对于 Vim 来说，以下几点尤为突出：

- 健康效益

  这对我来说是最重要的一点。在我职业生涯早期，我大量使用 Vim，不过和许多开发者一样，在 2015 年 VS Code 发布后就转向了它。我在键盘前花费了大量时间，到了 2020 年，我被重复性劳损（RSI）折磨得如此严重，以至于我花了六个月的时间完全靠语音编程（一篇关于这个话题的博客文章让我获得了超出预期的关注）。一个朋友建议我重新转向模态编辑，这对我来说产生了巨大的改变。绝大多数 Vim 按键操作不需要用同一只手同时按住多个键，这极大地减轻了腕管综合症的困扰。

- 性能表现

  大多数 IDE 都有某种"vi 模拟"层或插件，让你可以在不完全切换到新编辑器的情况下获得一些模态编辑的健康效益。但是等待 VS Code 启动并加载所有你熟悉和喜爱的扩展已经成为许多人的一种冥想练习（或者是重返社交媒体刷屏的机会）。相比之下，当我加载我的 LazyVim 配置时，它会很贴心地告诉我加载所需的时间：56.98 毫秒。对于我这个反应迟钝的人类来说，这简直是瞬间完成。

- 开发效率

  这是一个有争议且主观的话题。工具的好坏取决于使用者的水平，我当然知道有一些优秀的程序员能够熟练运用他们的 VS Code、Emacs 或 JetBrains 配置。尽管如此，我真的相信一个精心调教的 Vim 配置可以超越它们所有。

- 开放生态系统

  自从 Nadella 掌舵以来，我非常敬佩微软对开源软件的态度，但 VS Code 正在显示出越来越多的专有锁定迹象（尤其是在其 AI 集成方面）。相比之下，Neovim 生态系统是一个充满活力的开放社区，每周都会出现一些在 VS Code 中永远不会尝试的创新插件。

## [1.2. 为什么特别选择 Neovim](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-1/#_why_neovim_specifically)

如果你决定使用 Vim，你很快就会发现有两个现代变体：Vim 和 Neovim。它们都是 90 年代原始开源 Vim 代码的直系后裔。Neovim 于 2014 年从 Vim 分支出来，其愿景是重构并现代化其代码库和功能集。

这两者都在积极维护中，且都有潜力让人感觉精致现代，尽管要实现这种潜力需要一些配置。它们各自都拥有非常强大的插件生态系统，但 Neovim 有一个杀手级特性：除了其兄弟版本使用的原生 VimScript 外，它还引入了 Lua 编程语言用于插件开发（和配置）。

仅就 Lua 本身而言，并不会使 Neovim 本质上比 Vim 更好。然而，虽然大多数 Vim 插件也能在 Neovim 上运行，但反过来却并不总是如此，而且有一些同类最佳的 Lua 插件只能在 Neovim 上运行。

就本书而言，你的选择已经替你做好了：本书所讲的 LazyVim 发行版只能在 Neovim 上运行。

## [1.3. LazyVim 简介](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-1/#_introducing_lazyvim)

Vim 和 Neovim 的主要缺点是，虽然它们有能力提供与任何其他 IDE 相同（或更好）的现代编辑体验，但它们的初始状态并非如此。Vim 一直保持着与过时的 vi 工具的兼容传统，而 Neovim 也只是略微偏离了这一传统。当你首次安装 Neovim 时，你得到的是一个相当朴素的代码编辑体验。

2020 年当我从习惯了 VS Code 带来的出色功能后重新转向 Vim 时，我花了两周时间才让配置达到我想要的状态，之后的几个月里我还在不断调整。最终的配置包含了大约 300 行 Vimscript，后来我将其移植为约 250 行 Lua 代码。说实话，我一向热衷于定制，我的 VS Code 配置实际上比这两者都要长！但我也得承认，VS Code 的开箱即用体验确实要好得多。

我研究了几个所谓的 Neovim "发行版"（预配置安装包）。我不会详细比较，但 LazyVim 是目前最出色的赢家，主要是因为它在开箱即用的简单体验和相对容易的定制配置之间取得了平衡。

需要明确的是，LazyVim 就是 Vim。编辑体验是完全一致的。它不像 Neovim 那样是 Vim 的新迭代或版本。相反，LazyVim 是一种理念；它始于对现代开发最佳插件配置的共识，以及让这些插件能够很好地协同工作的配置（让不同插件的键位绑定不相互冲突是手动管理编辑器配置时的主要痛点之一）。

但如果你在使用 LazyVim 时抱着这样的心态：这种体验将比你之前使用过的任何编辑体验都要好，并且接受你需要重新训练一些键盘肌肉记忆，你会发现它的设计非常周到。根据我的经验，这正是 2020 年代模态编辑体验应有的样子。

## [1.4. 选择终端](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-1/#_choosing_a_terminal)

如果你已经看到这里，你可能觉得已经准备好安装 Neovim 了。实际上，你还有一个决定要做。

Neovim 可以在许多不同的环境中运行（你甚至可以在 Visual Studio Code 内运行它！）默认情况下它是一个终端程序，但也有大量的图形界面（GUI）可用。我几乎尝试过所有这些界面，老实说，我认为它们相比于直接在终端中运行 Neovim 并没有任何本质上的优势。

我们将在本书后面简要讨论如何将 Neovim 连接到几个 GUI，但对于入门来说，我建议在终端中运行 Neovim。具体来说，是一个非常好的终端。

要获得最佳的 Vim 编辑体验，你需要一个 GPU 加速的终端。这是什么意思？基本上就是你将使用设计用于渲染照片级真实视频的芯片来渲染源代码。这听起来就像用它来做人工智能一样合理，对吧？

你需要自行研究以下选项，所以可以请教你喜欢的搜索引擎或当下流行的 AI 聊天机器人来帮你决定：

- Kitty Terminal

  这是我个人的首选。我发现它文档完善、配置简单且功能齐全。

- Alacritty

  可能是原始速度方面的赢家，但配置比较笨拙，功能也较少。

- Wezterm

  有一些非常巧妙的功能，但我发现文档不够完善，而且在使某些功能正常工作时遇到了困难。

- Windows Terminal

  如果你是 Windows 用户，它确实声称支持 GPU 加速，不过我发现 Neovim 在其中偶尔会出现无响应的情况。

- Windows Terminal

  如果你已经是 Warp 的用户而且离不开它，Neovim 也可以在其中运行。我发现使用体验有点卡顿，而且我不太喜欢 Warp 的外观和感觉（以及需要登录才能使用的事实）。

> （ethan）我在公司使用的是 tabby 或 MobaXterm。因为公司的电脑性能太垃了，使用上述的终端软件，可能会很卡。Alacritty 虽然不会卡，但是他对 Windows 的支持不太友好。

所以安装其中的一个或多个，直到你找到一个你喜欢的。如果你愿意，你也可以使用其他终端模拟器。你可能甚至不会注意到体验有什么不足，但我可以保证，如果你之后切换到 GPU 加速的体验，你会注意到这种改进。

## [1.5. 设置终端字体](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-1/#_setting_up_your_terminal_font)

LazyVim 及其插件在终端中看起来非常漂亮，你几乎不会相信它们不是 GUI 应用程序。为了实现这一点，它们依赖于包含大量编程相关字形的特殊字体。最显著的是，这让你可以看到代表你打开的文件类型的图标，同时还能在终端中提供漂亮的边框和类似窗口的行为。

要获得最佳的 LazyVim 体验，你需要安装这些特殊字体中的一个，并配置你的终端来使用它。实际上，即使你不是重度 Neovim 用户，你也应该在终端中使用这些字体。许多现代终端应用（这说法听起来有点怪，是吧？）在安装了这些字体后都会看起来更好。

访问 Nerd Fonts 网站以获取更多信息。如果你使用 Kitty，你只需要安装 NerdFontsSymbolsOnly 字体，如果在你配置的等宽字体中找不到某些符号，它会自动从该字体中提取符号。对于其他终端，你可能需要按照 Nerd Fonts 网站上讨论的那样安装和配置一个"打补丁的"字体。有很多选择可供选择。

你可以从许多最流行的编程字体中进行选择。下载和安装它们在很大程度上取决于操作系统，所以我就让 Nerd Fonts 网站上的指南来为你解释这个过程。

## [1.6. 安装 Neovim](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-1/#_install_neovim)

Neovim 几乎可以在任何能安装软件的地方运行，它只依赖标准的系统依赖项。主要的问题是，无论你使用哪种操作系统，你都有太多的选择！

你可以访问 Neovim 主页并点击"Install Now"按钮，从 Neovim 开发者那里获取针对你所选择（或不得不使用）的操作系统的最新安装说明。

### [1.6.1. 我应该安装哪个版本？](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-1/#_which_version_should_i_install)

与其发布周期相比，Neovim 的开发进度非常快，所以人们经常使用最新的每日构建版本。我很少在从 Github 主分支构建的版本中遇到 bug，所以通常来说是安全的。我通常在新的稳定版本发布时使用它，然后当某个插件更新说"如果你使用 Neovim 每日构建版本，这里有个很酷的新功能"时，我就会改为安装最新的 Neovim 构建版本。

我建议现在先从最新的稳定版 Neovim 开始，在写作本文时是 0.10.0 版本。如果可能的话，避免使用更老的版本。LazyVim 确实倾向于添加来自每日发布版本的功能，所以如果你开始像我一样对这个发行版感到兴奋，切换到预发布版本将是一个很自然的进展。

### [1.6.2. Windows](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-1/#_windows)

在 Windows 上，我建议使用 Windows Subsystem for Linux（WSL）并在其中进行所有开发。WSL 远超出了本书的范围，但微软和许多在线教程都对其有很好的文档说明。一旦你选择了一个兼容 WSL 的 Linux 发行版，设置好并在你选择的终端中运行它，你就可以使用下面的 Linux 安装说明来安装 Neovim。

如果你有理由或偏好在原生 Windows 上开发，最简单的方法是从 GitHub 上 neovim/neovim 仓库的 Releases 部分获取 MSI 安装程序。

如果你已经在使用 Winget、Chocolatey 或 Scoop 来管理你的 Windows 机器上的包，它们各自都有 Neovim 包。

请注意，如果你使用 Windows 而不使用 WSL，你还需要安装一个 C 编译器才能获得 treesitter 支持（这基本上意味着更好的语法高亮和代码导航支持）。遗憾的是，这不是一个简单的任务。这在 nvim-treesitter/nvim-treesitter GitHub 仓库中有文档说明，所以我在这里不会详细介绍。

### [1.6.3. MacOS](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-1/#_macos)

在 MacOS 上，大多数开发者都使用 Homebrew，所以如果你还没有安装它，我建议按照 brew.sh 上的说明进行安装。

一旦你安装并运行了 brew，使用命令 brew install neovim 就可以安装 Neovim。

如果你想追求最新特性，brew install --HEAD neovim 将安装最新的 Neovim 每日构建版本，这个版本可能是稳定的，但不能保证。

我发现相比其他 MacOS 上安装 Neovim 的选项，brew 的体验要友好得多，所以如果你还不是 Homebrew 用户，我强烈建议设置它。随着我们在 LazyVim 的旅程中深入，你会想要安装其他开源工具，而 brew 将是获取所有这些工具最简单的方式。

如果你不想使用 Homebrew，事情就会有点烦人。Neovim 开发团队并不维护 MacOS 安装程序，所以你必须下载一个 tarball 并解压它，然后从系统路径中的某个位置链接到二进制文件。如果你不知道这些是什么意思，说实话，还是用 Homebrew 吧，它更简单！

### [1.6.4. Linux](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-1/#_linux)

如果在你的发行版的默认包管理器中找不到 Neovim，那你用的确实是一个非常特别的 Linux 发行版！

所以只需运行 sudo pacman -S neovim、sudo apt install neovim、sudo dnf install neovim，或者使用你偏好的其他特殊包管理器的相应命令即可。

不过，一些发行版附带的 Neovim 版本可能非常过时。如果你想要每日构建版本，你可以在 neovim/neovim GitHub Releases 页面找到相关说明，或者需要深入研究你的发行版的文档。

在不太可能出现的情况下，如果你的 Linux 发行版没有自带 C 编译器，你还需要安装一个。对于大多数发行版来说，只需安装 gcc 包就可以了。

## [1.7. 尝试原始的 Neovim（如果你敢的话）](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-1/#_try_neovim_raw_if_you_dare)

安装完 Neovim 后，你可以通过在之前几节安装的终端中简单地输入 nvim（或者 nvim <文件名> 来打开特定文件）来尝试使用它。如果 Neovim 安装正确并且在你的系统路径中，你会看到一个视觉上不太吸引人的编辑器，看起来就像是从 90 年代的某个程序分叉出来的，而且刻意让它看起来像是 70 年代写的。

所以，至少它很诚实？

不幸的是，你现在被困住了。为了省去你疯狂地在 Google 上搜索"如何退出 Vim"，这里告诉你退出的命令是：先按 Escape，然后输入三个字符 :q!，最后按 Enter。因此，整个操作序列是 <Escape> <冒号> q <感叹号> <Enter>。

说真的，"如何退出 Vim"是 Google 上"如何退出..."这个搜索词的前三个自动补全之一。显然只有三星电视和 MacOS 的全屏模式比它更难退出！在我们深入了解 vim 的思维模型和命令模式后，我们就会明白为什么这个咒语是有效的。

> 如果你想的话，可以运行命令 <Escape>:Tutor<Enter> （如果失败的话，可以在终端使用命令：vimtutor）来打开一个交互式文本文件，你可以在学习 Neovim 基础知识的同时阅读和编辑它。我确实建议你在某个时候完成这个教程，但现在可能不是最佳时机。在 Vim 教程中很多"正常"的操作在使用 LazyVim 时都是不同的（而且更好！）。本书的其余部分并不假设你已经完成了这个教程。

## [1.8. 安装 LazyVim](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-1/#_install_lazyvim)

现在你已经安装并运行了 Neovim，让我们来配置它，让它看起来像是这个世纪开发的产品。

安装 LazyVim 需要使用一些 git 操作。既然你在阅读这本书，我假设你是一名软件开发者，因此对 git 有一定的了解。

在不同的操作系统上安装 LazyVim 的 git 命令基本相同，只是路径和环境变量略有不同。

### [1.8.1. 从零开始](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-1/#_start_with_a_clean_slate)

> 如果你已经有了 Neovim 配置，并且想在不丢失现有配置的情况下尝试 LazyVim，可以设置环境变量 NVIM_APPNAME=lazyvim。直接跳到下面的"克隆启动模板"部分，然后克隆到 ~/.config/lazyvim 目录而不是 ~/.config/nvim。如果你想让这些更改永久生效，可以在你的 shell 启动文件中设置 NVIM_APPNAME，或者将 lazyvim 配置文件夹重命名为 nvim。

首先，删除或备份所有现有的 Neovim 状态。如果你以前从未使用过 Neovim，这一步基本上是可选的，但我建议确保以下目录已被删除或移动：

**清理：适用于 WSL 的 Windows、MacOS 和 Linux**
删除或备份（使用 mv 而不是 rm）以下目录：

```bash
$ rm -rf ~/.config/nvim
$ rm -rf ~/.local/share/nvim
$ rm -rf ~/.local/state/nvim
$ rm -rf ~/.cache/nvim
```

**清理：不使用 WSL 的 Windows**
在 Windows 上，配置和数据文件夹的位置与 Unix 系统略有不同，但基本思路是一样的。只需使用 Powershell 命令替代 Unix 核心工具：

```bash
$ Move-Item $env:LOCALAPPDATA\nvim $env:LOCALAPPDATA\nvim.bak
$ Move-Item $env:LOCALAPPDATA\nvim-data $env:LOCALAPPDATA\nvim-data.bak
```

### [1.8.2. 安装其他推荐的依赖项](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-1/#_install_other_recommended_dependencies)

我强烈建议安装 lazygit、ripgrep 和 fd，LazyVim 使用这些工具来提供增强的 git、字符串搜索和文件搜索功能。大多数操作系统的包管理器都可以轻松安装这些工具。你可以在它们各自的 GitHub 仓库中找到更具体的安装说明：

- [jesseduffield/lazygit](https://github.com/jesseduffield/lazygit)
- [BurntSushi/ripgrep](https://github.com/BurntSushi/ripgrep)
- [sharkdp/fd](https://github.com/sharkdp/fd)

### [1.8.3. 克隆 LazyVim 启动模板](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-1/#_clone_the_lazyvim_starter_template)

你将使用 git clone 命令下载启动模板并将其复制到 Neovim 的用户配置目录中，然后删除 .git 文件夹。

这个启动模板就是字面意思：一个起点。所以你永远不需要从这个仓库拉取更改。相反，LazyVim 会自己管理自身和所有插件的更新。启动模板之所以是一个 git 仓库，仅仅是因为这样对 LazyVim 维护者来说更容易维护。从你的角度来看，你只是在下载仓库的当前状态，不需要知道它的过去或未来状态。

**克隆启动仓库：WSL、MacOS 和 Linux**
在 Unix 系统上，使用以下命令：

```bash
$ git clone https://github.com/LazyVim/starter ~/.config/nvim
$ rm -rf ~/.config/nvim/.git
```

**克隆启动仓库：不使用 WSL 的 Windows**
在原生 Windows 上，使用以下命令：

```bash
$ git clone https://github.com/LazyVim/starter $env:LOCALAPPDATA\nvim
$ Remove-Item $env:LOCALAPPDATA\nvim\.git -Recurse -Force
```

## [1.9. 仪表盘（Dashboard）](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-1/#_the_dashboard)

好了，你已经完成了本书最困难的部分，现在终于可以开始使用 LazyVim 了！使用与之前相同的终端命令：nvim。

当 LazyVim 设置一切并下载它认为必要的插件时，你会看到一连串的活动。你可能会看到它编译和安装一堆 treesitter 语法解析器；如果你看到"Show More"（显示更多）的消息，可以使用 G（即 Shift+g）跳到末尾。

一旦所有内容都安装完成，你会在一个由 Lazy.nvim 插件管理的窗口中看到已安装插件的摘要，我们稍后会讨论这个插件。现在，当你看到 Lazy.nvim 界面时，可以按 q 键。插件会将其解释为"退出 Lazy.nvim"，窗口就会关闭。

现在你可以看到 LazyVim 的仪表盘，这是你每次启动 LazyVim 时首先看到的界面。比起开箱即用的 Neovim 体验，这个界面要友好得多：

<img src="mymedia\dashboard-dark.png" alt="dashboard dark" style="zoom:50%;" />

如你所见，有几个命令可以通过单个按键与仪表盘进行交互。当然，最重要的是按 q 键退出！

这些选项大多是不言自明的，但我们会在后面的章节中深入讨论其中的一些选项。

## [1.10. Lazy.nvim 插件管理器](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-1/#_lazy_nvim_plugin_manager)

当你第一次打开 LazyVim 时，它会检查是否有可更新的插件，并在一个消息通知中给你一个概览，看起来会像这样：

<img src="mymedia\plugin-updates-dark.png" alt="plugin updates dark" style="zoom:50%;" />

由于 Neovim 默认非常基础，LazyVim 预装了大量实用的插件。而且这些插件很可能已经过时了，因为 Neovim 世界的插件开发速度快得惊人。

在很久以前，插件管理完全是手动过程。在不那么久远但仍然是过去的日子里，插件管理由各种插件来完成，但总感觉缺少些什么。

然后出现了名为 Lazy.nvim 的插件管理器，它是由后来创建 LazyVim 的同一个人开发的。虽然两者都由同一个人维护，但不要把 Lazy.nvim 插件管理器与 LazyVim 本身混淆。Lazy.nvim 严格来说只是一个插件管理器，而 LazyVim 是一个插件和配置的集合。Lazy.nvim 是其中的一个插件。

Lazy.nvim 有许多出色的功能，最显著的是只在需要时加载插件（因此名为"Lazy"），这使得你的编辑器启动速度非常快。它还有一个很好的用户界面来管理插件的安装和更新。

你可以在仪表盘中简单地按 l 键来访问这个界面，在仪表盘中标记为 Lazy。这个标签可能应该标记为 Lazy Plugin Manager 会更清楚一些，但现在你已经知道 Lazy 的含义了，所以不会忘记。

如果你没有主动显示仪表盘，你可以随时通过进入空格模式来显示插件管理器。我们将在下一章详细介绍空格模式，但现在：首先确保你处于普通模式，方法是检查活动窗口的左下角。如果不是，按 Esc 键进入普通模式。然后按空格键进入空格模式，再按 l 键调出 Lazy.nvim 插件管理器。

（别担心，这些按键绑定在一周之内就会成为你的第二天性。）

Lazy.nvim 插件管理器界面看起来是这样的：

<img src="mymedia\plugin-manager-dark.png" alt="plugin manager dark" style="zoom:50%;" />

弹出的这个窗口被称为浮动窗口。你会在不同的情况下看到这些窗口，通常是在需要处理交互数据时。这个特定的浮动窗口有它自己的一套按键绑定。这些按键绑定列在顶部，要注意它们都是大写的，所以在使用时需要按 Shift 键。

通常，我使用的唯一 Lazy.nvim 按键绑定是 S，用于同步（Sync）。这相当于在一个操作中同时运行安装（install）、清理（clean）和更新（update）。它确保实际安装的插件版本与 LazyVim 配置中指定的版本完全一致。

所以当"Plugin Updates"（插件更新）通知弹出时，只需按 Space-l，然后按 S，等待同步完成。之后按 q 关闭 Lazy.nvim 插件模式和浮动窗口，返回你之前的工作。

## [1.11. 关于管理点文件的说明](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-1/#_a_note_on_managing_dot_files)

如果你在多台不同的电脑上工作，你很快就会发现你不想在所有电脑上分别设置 LazyVim 配置。LazyVim 没有类似 VS Code 的"设置同步"功能，虽然存在这样的插件。

我推荐的替代方案是将你的配置文件存储在 git 仓库中。你可能会发现还有一些其他文件也想保存在那里，比如你的终端配置文件、.gitconfig 和 .zshrc / .bashrc / .config/fish/config.fish。

如果你使用 GitHub Codespaces，你可能已经用 git 管理了一些点文件。如果没有，我个人建议遵循 Atlassian 博客上那篇优秀的文章[《Dotfiles: Best way to store in a bare git repository》](https://www.atlassian.com/git/tutorials/dotfiles)（点文件：在裸 git 仓库中存储的最佳方式）中的建议。

在像 LazyVim 这样的发行版出现之前，人们很常见地将他们的 Vim 配置存储在公共仓库中，并相互借鉴想法。这种做法现在还没有完全消失，你可以在 GitHub 上的 [dusty-phillips/dotfiles](https://github.com/dusty-phillips/dotfiles) 仓库中找到我自己的点文件。

## [1.12. 总结](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-1/#_summary)

在本章中，我们简要讨论了 Vim、Neovim 和 LazyVim 的历史，以及它们为什么在今天仍然具有重要意义。然后我们介绍了 GPU 加速终端和 Nerd Fonts 的重要性。

我们弄清楚了如何在你使用的任何操作系统上安装 Neovim 及其依赖项，最后从其起始模板安装了 LazyVim。

在下一章中，我们将讨论 Vim 的核心特性：模态编辑，并深入探讨在 LazyVim 中用键盘可以做的许多事情。

# [第二章：什么是模态编辑？](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-2/#_what_is_modal_editing_anyway)

正如仪表盘上的字母所示，LazyVim 是以键盘为中心的编辑器。尽可能多的操作都可以在不需要在鼠标和键盘之间来回切换的情况下完成。当然，你仍然可以使用鼠标。你可以点击编辑器中的任何位置，与弹出的按钮和对话框进行交互，使用滚轮或触控板手势进行滚动，通过拖动边框来调整编辑器窗格的大小。但是，这些操作都可以使用键盘来完成，而且通常效率更高。

更重要的是，你可以通过最多按住两个键，甚至只需要一个键就能完成大多数操作。你很少需要将手指扭曲成痛苦（且危险）的姿势去按 Control + Shift + Alt + <某个键>。

Vim 是如何做到这一点的？答案是模式编辑（Modal editing）。

## [2.1. 模式编辑入门](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-2/#_introduction_to_modal_editing)

在 LazyVim 中，"模式"简单来说就是根据当前激活的模式，不同的按键会有不同的含义。例如，当你启动编辑器时，你处于"仪表盘模式"（Dashboard Mode），该模式下每个按键最常见的解释都直接列在仪表盘上。这种在特定模式下按键绑定的可发现性是 LazyVim 的一个普遍特点，相比原生 Neovim 不透明的默认行为来说是一个巨大的改进。

为了更好地理解这一点，按下空格键进入"空格模式"（Space mode）。空格模式是 LazyVim 特有的概念；它在原生 Neovim 安装中并不存在（不过如果你想在不使用 LazyVim 的情况下获得空格模式，你可以通过安装各种插件来重现这个效果）。

进入空格模式后，屏幕底部会弹出一个菜单。它看起来会像这样（我的菜单包含一些自定义设置，所以你的可能会有所不同）：

<img src="mymedia\space-mode-dark.png" alt="space-mode-dark" style="zoom:50%;" />

这是一个很大的菜单。现在我们需要关注的重点是 f 键，我们将用它来理解模式编辑。

如果你在仪表盘模式下按 f 键，会打开一个查找文件（Find file）对话框，这个对话框使用了我们稍后会讨论的选择器插件。但是，当你在空格模式下，按 f 键则会打开文件/查找（file/find）其空格模式的子菜单。

这就是模式编辑的核心含义：同一个按键的行为取决于当前的模式。正如空格模式菜单底部所示，你可以按 Escape 键退出空格模式并返回到仪表盘。现在就试试吧。

现在你回到了仪表盘模式，你可以按 n 键创建一个新的空白缓冲区（buffer）。

请特别注意缓冲区左下角，你会看到 INSERT 这个词：

<img src="mymedia\insert-mode-dark.png" alt="insert mode dark" style="zoom:50%;" />

还记得我说过空格模式是 LazyVim 特有的概念吗？插入模式（Insert mode）则是最初 Vi 编辑器的概念，后来的 Vim、Neovim，以及现在的 LazyVim 都继承了这一特性。在插入模式下，绝大多数按键的行为都和你在其他编辑器中的预期一样：它们会插入文本。所以你可以像平常一样正常打字。

在插入模式下，你可以使用 Control 和 Alt 键来访问一些快捷键。例如，你可以按 Control-r 进入"寄存器"（Registers）迷你模式，这会弹出一个你可以从中粘贴内容的"寄存器"列表。我们将在第 8 章详细介绍寄存器。现在，你只需要知道在插入模式下，按 Control-r 后跟加号键（即 Shift-=）将会从剪贴板中粘贴文本。

然而，对于任何非文本输入的操作（包括粘贴文本），你会更经常地切换到普通模式（Normal mode）来执行。普通模式是另一个主要的 Vim 模式，自 Vi 时代就存在了。

要从插入模式切换到普通模式，按 Escape 键。光标会从一条竖线变成一个方块，左下角的指示器也会变成蓝色的 NORMAL：

<img src="mymedia\normal-mode-dark.png" alt="normal mode dark" style="zoom:50%;" />

在普通模式下，按键的行为与插入模式完全不同。比如按 p 键，它不会在文档中输入字母 p，而是会从系统剪贴板中粘贴内容。

Vim 和 Neovim 的一些功能虽然不太容易发现，但它们的快捷键设计得很容易记忆。大多数情况下，执行某个操作的快捷键都会使用该操作相关的首字母。你可能会认为 p 代表"paste"（粘贴），但其实这个概念比剪贴板的概念要早得多。如果你觉得理解成"paste"更容易，那也没问题，但在 Vim 的术语中，它实际上代表"put"（放置），在本书中我们也会使用这个词。

来看个不同的例子：在插入模式下按 Control-r 会弹出寄存器列表，但在普通模式下却是执行"redo"（重做）操作。如果你想在普通模式下访问寄存器列表，需要按 "（引号，即 Shift-单引号）键。

如果这些听起来很混乱，也不用担心。你的大脑和肌肉记忆会比你想象的更快适应，你也始终会明白，普通模式下的行为与插入模式下的不同。

我很少在插入模式下使用非文本输入的命令，而是习惯先切换回普通模式再执行这些命令。这样做并不会增加太多按键次数，而且避免了同时按住多个键的麻烦。

从插入模式退出到普通模式，统一使用 Escape 键。这就带来一个重要问题：你会频繁使用这个键，但是每次都要把手从主行移动到左上角的 Escape 键再移回来，这样的操作效率其实不高。

对于这个问题，有几个常见的解决方案：

- 如果你使用的是可自定义的键盘，你可以把 Escape 键放在更方便按到的位置。这就是我的做法。我用的是 Kinesis Advantage 360 键盘，虽然这个键盘的设计看起来有点奇特，但我把 Escape 键重新映射到了"拇指区"，这样按起来就和 Enter、空格、退格键一样方便了。

- 你的操作系统一般都支持键盘重映射。很多使用模式编辑器的用户会把几乎用不到的 Capslock 键改成 Escape 键。（对于非模式编辑器的用户来说，可能会更喜欢把 Capslock 改成经常需要按住的 Control 键，特别是在笔记本键盘上）。

- Neovim 本身也支持键位重映射。我们稍后会在 LazyVim 部分详细讨论如何设置。一个常见的做法是把一些在输入文本时不太可能连续按到的组合键映射成 Escape 键。比如，你可以设置在插入模式下按 jk、jj 或 ;; 来切换到普通模式。我试过这种方法，但不太喜欢，因为当你按下第一个键时，Neovim 会等待看你是要输入命令还是继续输入文本，这个延迟让我觉得不太舒服，不过你可能会喜欢这种方式。

- 另外，Control-C 组合键也可以退出插入模式，这个是默认就有的，不需要额外设置。不过我个人不太喜欢这种方式，因为需要按两个键，而且在我用的 Dvorak 键盘上，按 Control-C 比在 qwerty 键盘上要难得多，毕竟在 qwerty 键盘上 C 键就在底排靠近 Control 键的位置。

现在暂时不用急着改键位设置，先试着习惯现有的 Escape 键位置，看看是否真的觉得不方便。

当你进入普通模式后，肯定还是要回到插入模式来输入文本的。有几种不同的方法可以做到这一点。下面介绍几个最常用的：

i 键可以在光标当前位置之前插入文本。这意味着你可以（虽然很笨拙）通过重复按 i <Escape> i <Escape> 来向左移动光标。当你按 i 键时，你可以在当前位置之前插入文本，然后按 Escape 退出插入模式，这时光标就会停在新的"之前"位置。

有时候，你可能想在光标当前位置之后进入插入模式。这时就要用 a 键了（记忆方法：i 代表 Insert Before（在前插入），a 代表 Append 或 After（在后添加））。

在浏览文档时，你会发现经常需要在这两种模式之间切换，因为我们后面要讲到的各种导航命令，有时会把光标放在你需要插入的位置之前，有时会放在之后。所以记住这两个命令都很重要。

还有两个非常常用的操作是在当前行的最开始或最末尾插入文本。虽然你可以先用导航命令移动到行首或行尾，然后再用 i 和 a，但直接用 I 和 A 命令会更方便（注意这两个是大写字母，需要按住 Shift 键）。

### [2.1.1. 关于按键助记的说明](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-2/#_a_note_on_keybinding_mnemonics)

这些相关的按键绑定通常会被分配给同一个字母的小写和大写版本。你会发现小写版本通常表示"做某事"，而大写版本要么表示"做同样的事情，但范围更大"，要么表示"做相反的事情"，具体取决于情况。在这里，i 和 a 表示"在光标前后插入一个字符"，而 I 和 A 则表示"在光标前后插入，但范围更大（即在行首或行尾）"。

举个"做相反的事情"的例子，看看 o 和（按住 Shift 的）O 键，这是另外两种进入插入模式的方式。

o 键用于在当前行下方创建新行并进入插入模式。对于"做相反的事情"的情况，大写的 O 表示"在当前行上方创建新行并进入插入模式"。

> 助记口诀"Open（打开）一个新行在上方/下方"可以帮你记住这个不太容易记住的 o 命令。

最后一个需要按两个键的有用命令是 gi。这是先按一下 g 再按一下 i。它的意思是"转到上次进入插入模式的位置，并再次进入插入模式"。在这种情况下，g 键实际上是切换到一个我称之为"Go To（转到）"的小模式，不过并非所有从这个模式可以访问的命令都严格与"转到"有关。你可以在普通模式下按 g 键，然后等待窗口底部弹出菜单，就能看到"Go To"模式下所有可用的命令列表：

<img src="mymedia\goto-mode-dark.png" alt="Go To Mode" style="zoom:50%;" />

我们稍后会介绍大部分命令，但请注意其中有 i 键，标注为"Move to the last insertion and INSERT（移动到最后插入的位置并进入插入模式）"。所以如果你忘记了如何返回上次插入点，可以进入 Go To 模式并查看菜单来找到 i。

反复练习所有这些命令（a、i、o、A、I、O 和 gi），输入一些文本，然后按 Escape 返回普通模式。然后再试一次。用鼠标在文本中移动光标（我保证我们很快就会学习键盘导航），在不同位置尝试这些命令，看看它们的行为。

要充分熟悉在普通模式和插入模式之间的切换。你可能认为会在插入模式下花费大部分时间，但事实是代码的编辑频率远高于新写代码，你会经常在这两种模式之间切换。

## [2.2. 可视模式](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-2/#_visual_mode)

LazyVim 从其前辈那里继承的另一个主要模式是"可视"模式。可视模式用于选择文本。通常，你可以进入可视模式，然后使用许多与普通模式相同的导航键来移动光标。由于我们还没有介绍这些导航按键，我会把可视模式的详细讨论推迟到第 8 章，到那时我们会有必要的基础知识。

## [2.3. 命令模式](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-2/#_command_mode)

命令模式与我们之前看到的其他模式不同，其他模式大多是子菜单或编辑器级别的"主要"模式。你可以在普通模式下使用 :（即 Shift+分号）进入命令模式。在 LazyVim 中，这会弹出一个小部件，你可以在其中输入所谓的"Ex 命令"。这个名称来自 vi 的前身 ex，这些年来除了作为 Vim 的一部分外，它基本上已不再被使用。

本质上，你可以在这个小部件中输入各种命令，并期望产生特定的行为。它实际上更类似于 Sublime Text 和 VS Code 普及的命令面板，尽管体验很不一样。

你已经从第 1 章知道一个 ex 命令了！还记得 <Escape><Colon>q!<Enter> 这个退出编辑器的命令吗？现在你知道了 Escape 是从任何模式返回到普通模式。冒号用于切换到命令模式，q 是 quit（退出）的简写（如果你不在意按键次数，也可以输入完整的 quit）。感叹号表示"不保存"，回车键表示"提交 ex 命令"。

举个例子，让我们看看 write 这个 ex 命令。输入 : 后面跟着 write myfile.txt，像这样：

<img src="mymedia\command-mode-write-dark.png" alt="command mode write dark" style="zoom:50%;" />

按回车键确认并执行命令，这将以给定的名称保存文件。

> 大多数命令可以缩写为它们最短的唯一公共前缀。你通常可以输入 :w myfile.txt 而不是 :write myfile.txt。最常用的命令甚至有特殊的组合命令，比如 :wq 会保存并退出，不过你可能会更喜欢使用 :x，因为它更短。

命令模式有点奇特。它有点像插入模式，因为你可以在其中输入文本，一些在插入模式下有效的快捷键在命令模式中也有效（包括用 Control-r 从寄存器中粘贴）。但其他快捷键在命令模式中的行为是不同的。最重要的一个是 Tab 键，它会对命令执行一种"tab 补全"。例如，:q<Tab> 会弹出一个像这样的菜单：

<img src="mymedia\command-tab-dark.png" alt="command tab dark" style="zoom:50%;" />

这个补全菜单的导航方式令人困惑。你可能需要把这部分内容加入书签或做些笔记，直到你习惯为止！

首先，如果你想在菜单中选择不同的条目，你肯定会认为可以使用方向键，对吧？确实可以，但这很混乱，因为你需要用左右键来实现上下移动。我知道！这很让人费解，对吧？

这主要是因为菜单在 LazyVim 中的外观与原始 Vim 不同，但按键映射没有改变。所以我建议使用 Tab 和 Shift-Tab 来选择菜单中的不同条目。这更容易记住，也更容易形成肌肉记忆：按一次 Tab 显示菜单，再次按 Tab 可以在菜单条目中循环选择。

其次，确认这些菜单条目时有一些细微差别。在上面的例子中，你可以直接按 Enter 确认选择并执行它。然而，有时你可能想确认选择后继续编辑命令。一个很好的例子是 :e 或 :edit 命令。

这个命令用于打开文件系统中的文件，但你必须输入完整的文件路径。例如，如果你有以下目录结构：

```bash
.
└── foo
    ├── bar
    └── baz
    │   └── fizz.txt
```

...并且你已经打开了 Neovim，要打开 fizz.txt 文件，你需要输入以下内容：

```
:e foo/baz/fizz.txt
```

如果需要访问深层嵌套的目录，这样输入会很麻烦。幸运的是，你可以使用 tab 补全功能。你可以输入 :e f<tab>b<tab><tab><tab> 来选择 foo/baz，但此时菜单仍然是打开的：

<img src="mymedia\edit-baz-dark.png" alt="edit baz dark" style="zoom:50%;" />

如果你现在按 Enter，它会打开 baz 文件夹而不是仅仅确认选择，这不是你想要的。如果再按 Tab，它会继续在菜单中循环。

相反，你有几个选择。向下箭头键会（不直观地）"进入"选中的目录，让你可以在其中的文件间使用 tab 切换。或者，使用 Control-y（y 代表"yes"）组合键。这将确认 baz 的选择并关闭菜单，但保持你在命令模式中。现在你可以再次按 tab 来补全命令中的 fizz.txt 部分。

可以重新映射这些键使其更像其他软件，说实话我认为这是 LazyVim 应该默认做的事情之一。不过我还没有找到我喜欢的组合，所以我就继续使用默认的键位绑定。

你可能不会在命令模式下花太多时间。例如，在 LazyVim 中有更简单的方法来打开文件，退出编辑器也是如此。如果你需要处理更复杂的命令历史，还有一个特殊的窗口可以让你用插入模式和普通模式来编辑命令，我们稍后会介绍。

现在，记住 <Tab> 和 Control-y，你就能在需要时导航命令菜单了。

顺便说一下，最重要的命令是 :help。Vim 是在人们还没有随时访问互联网的时候创建的，所以它有一个传统，就是将所有文档都随编辑器一起发布。例如，如果你记不住粘贴文本的快捷键，可以试试 :help put。或者，如果你想知道 Control-R 快捷键的作用，可以试试 :help CTRL-R。当然，Vim 的帮助文档也已经被你喜欢的搜索引擎和 AI 聊天机器人包揽了，所以如果你愿意的话也可以用这些新方式来查询。

## [2.4. 总结](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-2/#_summary_2)

在本章中，我们熟悉了模态编辑的概念和 LazyVim 最重要的模式。随着我们学习的深入，还会遇到其他的小模式，但掌握普通模式、插入模式和命令模式（以及它们之间的切换方法）将让你在 LazyVim 的使用之路上走得更远。

在下一章中，我们将学习在文档中移动光标的各种不同方法。

# [第三章：光标移动](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-3/#_getting_around)

软件开发人员花在编辑代码上的时间远比写代码的时间多。我们总是在调试、添加功能和重构。

事实上，我最常做的事情就是在代码库的某个特定行添加 print/printf/Println/console.log。

如果你来自更常见的文字处理或文本编辑生态系统，在 Vim 的模态范式中，代码导航是最不同的部分。即使你习惯了 Vim，LazyVim 默认附带的一些插件也提供了不同于传统 Vim 的代码导航方法。

在 VS Code 中，从代码中的一个点移动到另一个点，最快的方式通常是使用鼠标。对于小幅度移动，方向键效果很好，它们可以与 Control、Alt 或 Cmd/Win 键组合使用，以实现更大幅度的移动，比如按词、段落移动，或移动到行首行尾。还有许多其他键盘快捷键可以让移动更容易，而且语言服务器的支持允许简单的语义代码导航，如"转到定义"和"转到符号"。

Vim 也支持鼠标导航，但一旦你熟练掌握了导航键位映射，你就不会经常使用鼠标了。LazyVim 为与 VS Code 相同的语言服务器协议功能提供了键位绑定，而且这些功能通常更容易访问。Vim 的最大区别在于，当编辑器处于普通模式时，整个键盘都可以用来进行导航操作。

## [3.1. 查找文本](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-3/#_seeking_text)

LazyVim 自带了一个名为 flash.nvim 的插件，这是 LazyVim 的维护者创建的，与 LazyVim 完美集成。

这个插件提供了一种代码导航模式，这种模式在各种 vim 插件中已经存在多年，历史上一直颇具争议。许多长期使用 Vim 的用户认为它破坏了 Vim 的范式。我不会详细解释原因，但我承认这在旧版本的范式中确实如此，不过在 flash.nvim 这样的现代版本中，这个问题已经不那么明显了。

如果你能看到想要导航到的代码（即文件当前已打开且代码在视图中），flash.nvim 几乎总是将光标移动到那里的最快方式。诚然，这至少需要按三个键，但这三个按键不需要心算或逐步"靠近"目标直到到达，这是其他一些 Vim 导航技术（以及非模态编辑）中出现的两个效率较低的问题。

要调用 flash，在普通模式下按 s 键。我把 s 记为"seek"（查找）的助记符，虽然我也听说过有人称之为"sneak"（潜行）或"search"（搜索）模式。在 LazyVim 中搜索是一个不同的行为（它不在意文本是否当前可见），而"潜行"听起来不太浅显易懂，所以我使用"Seek"（查找）。

当你按下 s 时，首先要注意的是文本会褪色为统一的颜色，状态栏中会出现一个小闪电符号，表示 Flash 模式已激活：

<img src="mymedia\seek-active-dark.png" alt="seek active dark" style="zoom:50%;" />

由于你知道想要将光标移动到哪里，你的眼睛可能正盯着那个位置，而且你确切知道那个位置的字符是什么。所以在进入查找模式后，只需输入你想要跳转到的字符即可。

例如，在下面的截图中，我想要修复本节标题中的拼写错误，将 Test 改为 Text。

<img src="mymedia\seek-s-dark.png" alt="seek s dark" style="zoom:50%;" />

我按下了 ss，截图中的每一个 s（包括大写的）都变成了蓝色。状态栏中闪电图标旁边有一个 s 字符，表明我已经查找了 s。

此外，靠近光标（位于底部段落）的所有 s 字符旁边（右侧）都有一个绿色标签。如果我想跳转到这些 s 字符中的任何一个，我只需输入对应的标签，就能立即跳转到那里。

然而，我想要到达的字符距离太远，没有唯一的标签，因为我的文本中有很多 s 字符。没关系！我只需要输入目标 s 字符右侧的字符，也就是 t。现在我的屏幕看起来是这样的：

<img src="mymedia\seek-st-dark.png" alt="seek st dark" style="zoom:50%;" />

现在，文件中所有的 st 组合都以蓝色高亮显示，由于 st 的数量比单独的 s 要少，所有这些实例旁边都有一个标签。我想要移动到的文本标记为 p，所以我按下 p，光标就移动到了我想要更改的 s 字符处。现在我可以输入 rx 来将 s 替换为 x（我们将在第 6 章讨论代码编辑，但现在你已经体验到了）。

如果你在分割窗口中打开了多个文件（我们将在第 9 章讨论），查找模式可以用于将光标移动到屏幕上的任何位置，而不仅仅是当前活动的分割窗口中。

然而，查找模式也有缺点，至少在 flash.nvim 的实现方式中是这样。有些字符你无法直接移动到，因为在标记匹配到达目标位置之前就用完了可搜索的文本。对我来说，这种情况最常发生在我想要编辑行尾时。如果我输入 sn 是因为我想编辑一行以 n 结尾的文本，但是在我的光标附近有很多 n 字符比我想要移动到的那个更近，flash 可能不会标记我想要移动到的 n，而且它不接受回车键作为"下一个字符"输入。

因此，我不会在行尾附近使用查找。相反，我会查找同一行中间某个词，然后使用 A，正如你可能记得的，这会让我在行尾进入插入模式。或者，如果我不想进入插入模式，我会使用 $ 符号（Shift+4），这是普通模式下"将光标移动到当前行末尾"的命令。

## [3.2. 滚动屏幕](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-3/#_scrolling_the_screen)

查找模式只在你想跳转的文本在屏幕上可见时才有效。你无法标记看不见的内容！通常，这意味着你需要使用搜索或后面将讨论的更大范围或更具体的移动命令，但也有一些快捷键可以用来滚动屏幕，让你在跳转前看到目标。

这些快捷键按照 Vim 标准来说有点不寻常，因为它们大多使用控制键。多么反模态啊！根据我的经验，这些快捷键实际上并不常用。事实上，我已经忘记了其中一些，不得不查阅才能写这一章。

我最常用的滚动键绝对是 Control-d 和 Control-u，它们分别表示向下（down）和向上（up）。它们可以滚动半屏的文本。光标相对于窗口保持在相同位置，这意味着相对于文档，它会向上或向下移动半屏的文本距离。

如果你需要移动更远，可以使用 Control-f 和 Control-b 快捷键（向前forward和向后backward），它们会滚动整整一页文本。我不太喜欢这些，因为我永远不确定光标最终会在哪里，这让我感到迷失方向。但如果你需要快速滚动某些内容到可见区域以使用查找模式，它们会很有用。与 Control-d 和 Control-u 不同，Control-f 和 Control-b 可以加上数字前缀，所以你可以输入 5<Control-f> 来向前滚动 5 页。

要逐行滚动窗口，使用 Control-y 和 Control-e。我不知道为什么选择这些快捷键。它们没有任何助记含义。我很容易忘记它们，所以我从不使用它们。这些快捷键接受数字前缀，所以如果你能记住它们，它们对于微调文本位置很有用。这些快捷键的主要优点是除非光标会滚动出屏幕，否则它们不会移动光标，所以如果你正在处理某一行并需要更好的可见性但不想移动光标，你可以使用 Control-y 和 Control-e。

我不使用这些键的原因（除了缺乏好记的助记符外）是我更喜欢使用 z 模式进行相对光标定位。

### [3.2.1. Z 模式](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-3/#_z_mode)

z 菜单模式是光标定位、代码折叠和各种随机命令的混合体。你可以在普通模式下按 z 键查看列表：

<img src="mymedia\z-menu-dark.png" alt="z menu dark" style="zoom:50%;" />

如果你觉得这个菜单很大，那你还没见识到一半！还有许多其他的 z 模式快捷键太过晦涩，以至于 which-key 插件都懒得在菜单中列出它们！这里我会介绍三个最有用的滚动相关命令，其他的我们稍后再讨论。

我专门使用的相对光标快捷键是 zt、zb 和 zz。它们分别将光标所在行移动到屏幕的顶部、底部或中间。当移动到顶部或底部时，会在光标上方或下方保留几行作为上下文。

还有一些命令也会将光标移动到窗口的第一列，但与其记住那些快捷键，我建议将前面的命令与 0 组合使用，比如 zt0、zb0 和 zz0。0 命令就是"移动到行首"的意思。如果你的键盘有 Home 键，你也可以使用它，但在很多键盘上 0 更容易按到。

你可以通过输入 :help scrolling 在 Neovim 文档中找到其他滚动快捷键，但我刚才提到的这些可能已经足够满足你的需求了，因为你将学习到更多细致入微的代码导航方法。

## [3.3. Vim 的第一条规则](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-3/#_the_first_rule_of_vim)

Vim 有一条神圣的规则，我经常因为正当理由而违反它。除非你和我一样是个奇怪的人，否则你可能不应该像我这样经常打破它：

永远不要使用方向键移动光标。

这条规则的背景是，在大多数键盘上，将手移动到方向键需要大约十分之一秒，再移回主行又需要十分之一秒。我不确信这些零点几秒能累积成显著的时间，即使考虑到我一生中已经输入了数百万个字符（是的，数百万。我曾经计算过）。

但我确实认为，在大多数键盘上，方向键可能会对你的手部长期健康造成不良影响。而且说实话，当你越来越习惯使用 Vim 的替代按键绑定时，你就会越来越倾向于使用它们。

Vim 的方向键绑定在你第一次看到时可能显得很反直觉：h、j、k 和 l。这些键分别对应左、下、上、右方向。如果你觉得用 l 表示右而不是左很奇怪，或者你在想为什么跳过了 i（因为这看起来是按字母顺序排列的），看看你的键盘就明白了。

如果你使用标准 QWERTY 键盘，字母 h、j、k 和 l 就在你右手所在的主行上，按这个顺序排列，因此它们是整个键盘上最容易按到的键。

在 Neovim 中打开一个较大的文件（你可以使用 :e 路径/文件名），然后尝试使用主行键（h、j、k 和 l）来左右上下移动光标。在你练习的时候，我来告诉你为什么我不使用它们，因为我有三重特殊性。

首先，我是左撇子，所以右手主行感觉不太容易操作。其次，我使用 Dvorak 键盘布局已有二十年。j、k 和 l 键不在我的主行上。第三，我使用 Kinesis Advantage 360 键盘，除了其他奇特的布局特征外，它的方向键就在手指可及的范围内，所以我不需要移动手就能按到它们。

由于命运的奇妙转折，这些特殊性某种程度上相互抵消了。j 和 k 键恰好在我主导手（左手）的左右方向键正上方。所以这就是我用于导航的方式：左右方向键，j k。如果你没有我这么特别，你可能应该按照 Vim 设计的方式使用右手主行键。

Vim、Neovim 和 LazyVim 都非常善于重复使用移动命令，所以在阅读本书的过程中，你会发现 h、j、k 和 l 被用于许多不同的导航序列。花足够的时间来真正习惯它们。但要记住，如果你需要连续按这些键超过两次才能移动光标，那你就是在浪费按键次数。

## [3.4. 计数](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-3/#_counting)

Vim 中的绝大多数命令都可以在前面加上一个数字来重复执行多次。这个数字通常是在你想要重复的命令之前输入的一串数字。

例如，要将光标向上移动 15 行，你可以在普通模式下输入 15k。要向右移动 5 个字符，使用 5l。

这就是为什么 LazyVim 默认会有如此奇特的行号显示方式。请看下面的截图：

<img src="mymedia\relative-lines-dark.png" alt="relative lines dark" style="zoom:50%;" />

在这个截图中，我的光标位于第 126 行，这一行在左边栏中被高亮显示。这个行号也显示在窗口的右下角（虽然在这个截图中被裁掉了）。但在第 126 行的正上方，我们看到行号是 1，它下面也显示为行号 1。

假设我想将光标移动到"Scrolling the screen"这个标题处。

这一行旁边的数字是 5，所以我不需要数行或做任何心算来确定需要使用的计数。我只需输入 5j，光标就会移动到目标行。

现在你知道这些相对行号的用途了，我建议你保持它们开启，直到你习惯为止。如果你觉得它们令人分心或者根本不使用它们，你可以通过编辑 LazyVim 配置来改为普通行号显示。打开文件 ~/.config/nvim/lua/config/options.lua，这个文件应该是 LazyVim 为你创建的，但目前除了描述其用途的注释外可能没有其他内容。

> 你可以使用空格模式命令 <Space>fc 来快速在 LazyVim 配置目录中查找文件。这会弹出一个文件选择器，我们将在下一章详细讨论这个功能。输入 "xxx（options）" 并按 <Enter> 键来打开xxx文件。

要默认禁用相对行号，在文件中添加以下这行代码并保存：

```lua
vim.opt.relativenumber = false
```

然后重新打开 Neovim，你就会在左侧列看到绝对行号值。

就我个人而言，我觉得行号不是很有用，而且我不想浪费宝贵的屏幕宽度来显示这些字符。正如已经成为一个普遍的主题那样，我承认我可能有点特立独行！但如果你也想完全禁用行号显示，你需要在 options.lua 中添加第二行代码：

```lua
vim.opt.number = false
vim.opt.relativenumber = false
```

## [3.5. 查找模式](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-3/#_find_mode)

> （ethan）我个人觉得这个模式很鸡肋，主要是因为要自己数数，而且还要按数字键，太繁琐了。

如果你需要将光标移动到距离当前位置相对较近的位置，你可能想使用 LazyVim 的查找模式，而不是我们之前描述的 Seek 模式。Neovim 的默认查找模式相对有限，但启用 Seek 模式的 flash.nvim 插件使其变得更加好用。

要进入查找模式，按 f 键。和 Seek 模式一样，屏幕的一部分会变暗，提示你需要输入另一个字符。输入后，光标后所有该字符的实例都会被高亮显示。例如，fs 将高亮显示当前光标位置后所有的字母 s。

但是，查找模式和 Seek 模式的相似之处到此为止。查找模式不会显示标签，而是光标会立即跳转到光标后的第一个匹配字符。你还会注意到光标前的文本没有变暗，光标前的行中的匹配字符也没有被高亮。

相反，我们需要使用计数来跳转到字符的后续实例。如果我想跳转到第三个高亮显示的 s，我输入 3f，光标就会移动到那里。但是，如果你想跳转到更靠后的 s，你可能不想一个个数有多少个 s。幸运的是，在使用计数后，LazyVim 会保持你在查找模式中，所以你可以先猜测有多少个 s 字符，然后一旦接近了，就可以用新的计数重复。如果你只想向前跳一个 s 字符，你不需要输入计数，只需按 f 键就可以向前移动。

如果你数错了或猜错了跳得太远，别担心！你可以利用（大写）F 表示"向后查找"的特性，它也可以使用计数。所以如果你需要移动到第 15 个高亮显示的 s，完全可以先猜测 18f，发现跳得太远了三个，然后用 3F 跳回到前面的字符。

而且，如果你知道要查找的字符在文档中光标的后面或上面，你一开始就可以用 F 而不是 f 进入查找模式。这将立即开始向后查找而不是向前查找。如果你一开始就知道要向后或向前跳转指定字符的三个实例，你可以在首次进入查找模式时就使用计数。

还有一个查找模式的细微变体，我称之为"To"模式，尽管官方 Vim 助记符实际上是"Til"模式。你可以用 t 或 T 进入这个模式，具体取决于你想要移动的方向。

"To"模式的行为与查找模式完全相同，只是它会跳转到目标字符的前面。

你可能认为 To 模式有点多余，因为你可以很容易地使用查找模式后跟一个 h 来向左移动光标。但是当你将它与编辑文本的操作结合使用时，"To"模式非常有用，我们稍后会讨论这点。举个例子，如果你使用命令 d2ts，它会删除光标和它遇到的第二个 s 之间的所有文本，但保留那个 s。这比使用查找命令然后必须进入插入模式来添加 s 的 d2fsis<Escape> 要容易得多。

## [3.6. 按词移动](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-3/#_moving_by_words)

当 f 或 t 感觉太大，而带计数的光标移动又感觉太小时，你很可能会想使用词移动命令。在其他编辑器和 IDE 中，你可能习惯于按住 Control、Alt 或 Option 键的同时使用方向键来实现这个功能。

Neovim 更简单；你不需要把手移到键盘的方向键区域，也不需要同时按住多个键。

相反，你只需要进入普通模式并按 w 键就可以移动到下一个词的开头。如果你想移动到当前词的末尾，使用 e 键。如果你已经在当前词的末尾，e 将移动到下一个词的末尾。

这在你想要和计数组合使用时很有用：如果你需要移动到当前词之后两个词的末尾，按 3e。这相当于按三次 e，这会移动到当前词的末尾，然后是下一个词的末尾，最后是你想要到达的词的末尾。如果你需要移动到当前词之后特定数量词的开头，w 也可以加上计数前缀。

如果你想向后移动，使用 b 键。这会将你移动到当前词的开头，如果你已经在词的开头，它会移动到前一个词的开头。和之前一样，使用计数可以移动到更多词的开头。

令人惊讶的是，移动到前一个词的末尾需要多按一个键：g 后跟 e。这个助记符是"go to end of previous word"（移动到前一个词的末尾）。实际上，由于某些原因，你会发现很少需要这个功能，说实话我通常使用 be（b 移动到前一个词的开头，然后 e 移动到那个词的末尾）来移动到前一个词的末尾。不过，如果你确实使用 ge，它也可以与计数组合使用。你需要输入类似 4ge 这样的命令，具体取决于计数。命令 g4e 不会做任何有用的事情。

总的来说，你可能偶尔会听到 w、e 和 b 命令被称为"web"词。这只是表示"按词移动"。这些可能是你最常用的移动命令，比单个光标位置的移动更常用，这是因为大多数编辑操作往往涉及更改或删除一个词或一系列词。

## [3.7. 按词移动，但范围更大](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-3/#_moving_by_words_only_bigger)

"web"词的大写形式也是按词移动，但"词"的定义略有不同。具体来说，大写的 W 会移动到下一个空白字符之后，而小写的 w 会使用其他形式的标点符号来界定词。考虑在许多编程语言中对象的方法调用，它看起来像这样：

```lua
myObj.methodName('foo', 'bar', 'baz');
```

如果你的光标当前在行首，按 w 会将光标移动到行中的句点，再按一次 w 会移动到 m，后续按 w 也会在括号和引号处停留。

另一方面，如果你的光标在行首，按 W 会直接移动到"bar"参数的第一个引号处，因为那里是第一个空白字符所在的位置。

作为可视化说明，这里比较使用 w 和使用 W 时在代码行中的所有停留点：

```lua
myObj.methodName('foo', 'bar', 'baz')
-----ww---------w-w--w--ww--w--ww--w---->
------------------------W------W-------->
```

B、E 和 gE 这些移动命令的行为类似，它们是按空白字符分隔的词来移动，而不是按标点符号分隔的词来移动。

在 Vim 和 LazyVim 的默认配置中有一个比较烦人的问题：没有办法在 CamelCaseWords（驼峰命名）或 snake_case_words（蛇形命名）的单个词之间导航。虽然你可以使用 fC 或 t_ 之类的命令来实现，但我稍后会向你展示如何设置 nvim-spider 插件，它可以让在这些常见的编程命名方式之间的导航变得更简单。

## [3.8. 行目标](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-3/#_line_targets)

经常需要移动到当前编辑行的开头或结尾。如果你的目标是移动到这些位置并进入插入模式，通常可以使用 I 或 A；但如果你需要移动到那里并保持在普通模式（例如，为了删除或修改某个词），你可以使用 ^、$ 和 0 命令。

如果你熟悉正则表达式，你可能知道 ^ 用于匹配文本开头或行首，$ 用于匹配结尾，所以使用这两个键绑定来匹配当前行的开头和结尾的助记方式可能不会像最初看起来那么难记。

然而，这两个命令之间存在一定的不对称性：

- $ (Shift-4) 命令简单地表示"移动到行尾"，即结束换行符之前的最后一个字符，不管那个字符是什么。
- ^ 或插入符号 (Shift-6) 表示"移动到这一行文本的开头"。这里的"文本的"很重要：如果你的行开头有空白（比如缩进），^ 不会移动到最左边的列，而是移动到第一个非空白字符。

要移动到行的最开始位置，使用 0 键。0 是唯一一个映射到命令的数字键，因为其他数字键都用来开始计数。但用 0 开始计数没有意义，所以我们可以用它来表示"移动到第零列"。

还有一个命令可以移动到行尾但不包括空白字符，不过我从未使用过它，可能是因为我通常配置格式化工具来删除尾随空白，所以这种情况很少出现。

两个字符组合 g_（g 后跟下划线）表示"移动到最后一个非空白字符"。我猜 _ 看起来有点像"不是空格"，所以某种程度上也算是助记符？我提到它是为了完整性，但你可能不会经常使用它。你也可以组合其他已经学过的命令，这样就不用记住这个特殊的命令。例如，你可以使用三个字符 $ge（组合"行尾"和"向后移动到词尾"）或 $be 来移动到行内最后一个非空白字符。你有多个选择，选择你觉得最容易记住或最容易输入的方式即可！

## [3.9. 跳转到指定行](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-3/#_jumping_to_specific_lines)

当你编译代码或运行代码检查工具时，不可避免地会得到错误发生的行号（除非这个编译器特别没用）。

你可以通过以下方式跳转到特定行：

1. 输入行号作为计数，然后按（大写的）G。例如，100G 会将光标移动到第 100 行
2. 或者使用 ex 命令： :100<Enter>

G 命令也可以不带计数使用，这种情况下 G 命令会将你带到文件的末尾。

如果你想去到文件开头，可以用 1G，但由于这是一个非常常用的操作，你可以使用 gg（两个小写的 g）来代替。在所有情况下，g 的助记符都是"Go to"（去往），在 g 之后可以跟很多不同的命令（使用： :help g 可以了解我没有提到的那些命令，不过要注意 LazyVim 已经重新定义了其中的一些）。

因为"去往"某个行号是最常见的需求，所以最容易输入的 G 和 gg 命令被用于行号导航。

## [3.10. 跳转历史](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-3/#_jump_history)

所有这些跳转可能会让你感到有点迷失。幸运的是，有两个非常有用的键绑定可以让你回到之前跳转的位置。

Control-o 是我最常用的非模态 Control 键绑定。说实话，考虑到我使用它的频率，我应该把它绑定到一个更容易按到的位置。它基本上意味着"回到我跳转前的位置"。

这在编辑代码时特别有用。比如当你在文件深处编辑代码时，突然意识到需要在文件顶部导入一个库。你可以使用 gg 跳到文件顶部，用 s 寻找要添加导入语句的行，然后进入插入模式添加导入语句。现在你想回到之前正在处理的代码位置以便使用新导入的库。按几次 Control-o 就能带你回去。

Neovim 会保存所有跳转的历史记录，所以你可以在多个位置之间跳转（可能是为了查看文档或函数的调用签名），并且总能找到回去的路。

如果你跳转过头了，可以使用 Control-i 键绑定在历史记录中向前跳转。它就是 Control-o 的反向操作。我不知道为什么选择 i 和 o 这两个键；也许是因为它们在 Qwerty 键盘上是相邻的？它们的使用非常普遍，一旦你学会了，就不会忘记。

## [3.11. 总结](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-3/#_summary_3)

在 Vim 中，代码导航是一个很大的主题。你已经学会了足够多的命令，可以比大多数非模态编辑器更高效地在 Vim 窗口中导航。但这仅仅是皮毛，我们后面还会介绍更多有用的代码导航命令。

我们已经介绍了：

1. LazyVim 的 Seek 模式，用于跳转到可见窗口中的任何位置
2. 滚动命令，确保你想跳转的目标可见
3. 使用主行键移动光标，以及使用计数来倍增移动距离
4. Find 模式与 Seek 模式的区别，尽管它们表面上很相似
5. 一些用于按词移动和跳转到行内关键位置的标准键绑定
6. 跳转到特定行的方法
7. 如何导航回之前跳转过的位置

在下一章中，我们将学习更多关于打开文件和导航文件系统的内容。

# [第四章 打开文件](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-4/#_opening_files)

在上一章学习命令模式时，我们顺便了解了使用传统 Vim 方式（即 :edit 命令）来打开文件。另一个传统方法是直接在终端命令行中使用 nvim filename 来打开文件。

这两种方法偶尔会派上用场，但 LazyVim 预先配置了更现代的文件导航和打开方式。

## [4.1. 文件选择器简介](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-4/#_introducing_file_pickers)

LazyVim 自带两个不同的"选择器"插件：它们都是用于从列表中选择项目的工具。在本章中，我们将介绍这两个选择器，并就如何选择使用哪一个提供一些建议。虽然它们的外观略有不同，但在大多数情况下可以互换使用。

默认情况下，LazyVim 启用了 Telescope 选择器。它提供了一个具有预览和模糊搜索功能的选择器界面。如果你使用过许多现代编辑器中的命令菜单（或者甚至是 Github 或 Slack），你可能就知道我在说什么。选择器本身并不关心你要选择什么，它被用于 LazyVim 内置的或第三方插件提供的各种任务，包括打开文件、选择打开的缓冲区、项目范围的搜索等等。

你最常执行的选择器任务就是使用模糊搜索来打开文件。我每天要使用这个命令几十次，可能上百次，所以很幸运它有一个非常方便的快捷键。

在一个包含大量文件的代码仓库中工作时，文件选择器的优势最为明显。所以现在请用 Space q q 关闭 Neovim，然后在终端中使用 cd 命令切换到你最近在使用的项目目录（如果手头没有合适的项目，可以克隆你喜欢的开源项目来替代）。然后输入 nvim 重新打开 Neovim。

> 我刚才让你退出到终端是因为这样比较容易理解，但实际上也可以在 LazyVim 内使用 :cd 命令来切换目录。输入 :cd 目录路径 然后按回车，记住你可以使用 Tab 键来自动补全路径。现在如果你使用 :e 来打开文件，它们将会以你指定的文件所在目录作为相对路径。如果你使用文件选择器，文件路径可能是相对于当前工作目录的，也可能是相对于包含当前文件的项目目录的，这一点我们稍后会讨论。使用 :pwd 命令可以查看当前所在的目录。

好，假设你现在在一个大型项目的根目录下，想要打开任意一个文件。只需按两次空格键（即 Space Space）就可以弹出"当前项目中的文件"选择器。就像我提到的，这是你键盘上最容易按的快捷键组合。在大多数键盘上，空格键都很大，而且你用的是最有力的拇指来按它。和往常一样，按一次空格键会弹出 Space 模式菜单，你可以看到再按一次空格键会显示"查找文件（根目录）"。

对于包含本书当前内容的项目，选择器看起来是这样的：

<img src="mymedia\telescope-current-project-dark.png" alt="telescope current project dark" style="zoom:50%;" />

选择器分为三个主要区域：左上方是结果列表，右侧是当前选中文件的预览，底部是输入区域（在这个例子中标记为"Git Files"）。

输入区域是当前焦点所在，并且处于插入模式，所以你可以直接开始输入想要打开的文件名。这是一个"模糊搜索"（这个概念由 Sublime Text 普及），意味着你可以跳过一些字母，从而节省宝贵的时间。例如，如果我输入 ch3，我的列表就会被过滤为以下文件：

<img src="mymedia\telescope-ch-3-dark.png" alt="telescope ch 3 dark" style="zoom:50%;" />

只有路径中按顺序包含这三个字符（中间可能有其他字符）的文件才会显示。选择器会在结果中高亮显示这三个字母，这样你就能轻松看到为什么会匹配到这些文件。

另外请注意，默认情况下，匹配是不区分大小写的。我输入的是小写字母 c，但它也能匹配文件名中的大写 C。这通常足以将搜索结果缩小到你需要的范围。不过，如果你在搜索中使用任何大写字母，它就会切换到区分大小写的模式（这有时被称为"智能大小写"）。

这意味着 Ch 会匹配所有的 Chapters，但 cH 则不会匹配任何内容。更有趣的是，chF 也不会匹配任何内容，因为大写字母 F 的存在使整个搜索变成了区分大小写的模式，而章节名都是以大写 C 开头的，所以小写 c 就无法匹配它们（这个例子与上图无关）。

有时你开始输入一个词，然后发现需要匹配路径中更早的部分来区分它。例如，我在 Fablehenge 的这些源文件中开始输入 outline：

<img src="mymedia\telescope-outline-dark.png" alt="telescope outline dark" style="zoom:50%;" />

"Outline" 是这个应用中的一个常见词。有 243 个匹配的文件，这时我意识到可能应该在前面输入 comp 来将范围缩小到仅组件目录中的文件。虽然我可以切换到普通模式然后编辑行首，但直接输入 <space>comp 会更快。选择器会将空格解释为"重新过滤这些行，从开头模糊匹配这个新词"。现在我们可以看到只有 comp...outline 的文件被匹配到：

<img src="mymedia\telescope-outline-comp-dark.png" alt="telescope outline comp dark" style="zoom:50%;" />

这个结果可能会让人惊讶；最有可能的匹配显然是列表底部被选中的那个。其他 27 个匹配行都包含了 "outline" 和 "comp" 这两个词的所有字母，按从左到右的顺序排列。但是，由于模糊匹配算法的原因，这两个词实际上可以重叠！例如在倒数第二个条目中，匹配 "comp" 的 c 在 outline 这个词之前，o 在这个词中，而 m 和 p 都在 outline 这个词之后。选择器并不在意这一点，不过它会将匹配字母距离更近的结果排在更重要的位置，所以它们会出现在结果的底部。

你可以使用上下箭头键（或者 ctrl+p 和 ctrl+n ）在搜索结果中选择不同的文件，选中的文件预览会显示在右侧窗口中。一旦找到想要打开的文件，按回车键就可以在当前活动的 Neovim 窗口中打开它。

在 Telescope 中，输入区域甚至有自己的普通模式！你可以通过按一次 Escape 键进入这个模式。现在如果你按 j 或 k，就可以在不把手移到方向键的情况下选择列表中的不同文件。此外，h 和 l 键可以让你在输入框内移动光标，你可以使用 i 或 a 键在新位置进入插入模式。大写的 "I" 和 "A" 键则允许你移动光标到行首或行尾并进入插入模式。

你甚至可以使用我们在第三章讨论过的 Seek 模式，尽管它在选择器中的工作方式有点不同。当你在 Telescope 选择器的普通模式下按 s 键时，你可以跳过输入要搜索的字符的步骤。相反，LazyVim 会立即在文件名左侧为选择器中的每一行标上一个字符：

<img src="mymedia\telescope-seek-dark.png" alt="telescope seek dark" style="zoom:50%;" />

这些字符是选择器中每一行的标签。只需在键盘上按下显示的任意一个字母，与该字母关联的那一行就会被选中。然后按回车键就可以实际打开文件（或者，如果不是文件选择器，则执行该选择器的默认操作）。

最后，如果你在 Telescope 窗口中，但最终决定不想打开任何文件（或者你已经从预览中获得了需要的信息），连按两次 Escape 键即可。第一次按键会进入 Telescope 选择器的普通模式，第二次按键则会关闭选择器。

如果你需要滚动预览窗口来查看文件中更下方的内容，可以使用我们在基本导航章节中讨论过的相同按键：Control-d、Control-u、Control-f 和 Control-b。

## [4.2. "Root" 和 "Cwd" 的区别](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-4/#_the_difference_between_root_and_cwd)

<Space><Space> 命令被映射为"查找文件（根目录）"。打开文件选择器还有两种方式，就是使用 <Space>f 打开"file/find"菜单，然后再按 f 或 F。

<Space>ff 和 <Space><Space> 是一样的。它们都会打开"查找文件（根目录）"，只是另一种较长的方式而已。我猜测之所以在两个地方都存在这个功能，是为了让用户可以选择将其他操作映射到 <Space><Space>，同时仍然可以通过 <Space>ff 访问选择器功能。

<Space>fF（注意第二个 F 是大写）也类似；它被映射到一个叫做"查找文件（cwd）"的操作。如果你在你的项目中运行它，你可能会发现它看起来和"查找文件（根目录）"做的是完全相同的事情（这取决于你的项目是如何设置的），所以有两个独立的键绑定的目的可能会让人感到困惑。

### [4.2.1. 当前工作目录](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-4/#_current_working_directory)

"cwd" 是 "当前工作目录"（Current Working Directory）的缩写，默认情况下，它指的是你在终端中输入 nvim 打开编辑器时所在的目录。你可以通过进入命令模式（按 :），然后输入 cd path/to/directory 来改变整个编辑器的 cwd（记住，所有命令后面都要按回车键）。现在如果你使用 <Space>fF，文件列表将会相对于你切换到的新目录显示。

如果你不确定当前所在的目录，可以使用 :pwd 命令（"print working directory"的缩写）来在一个小的通知窗口中显示。cd 和 pwd 与 bash、zsh 和许多其他 shell 中用于改变和显示工作目录的命令是相同的，所以你可能已经很熟悉它们了。

我们还没有讨论编辑器分屏或打开新标签页的内容，但是为了将来参考：实际上不同的窗口可以有不同的工作目录。改变当前窗口目录的命令是 :lcd，是"local change directory"的缩写。这可以成为同时处理多个项目的强大方式（例如，如果你是一个同时负责后端和前端项目的全栈开发者）。不过，LazyVim 的"Root"目录概念可以半自动化处理这个问题。

### [4.2.2. 根目录](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-4/#_root_directory)

根目录不是 Vim 的概念，而是语言服务协议（LSP）的概念。LSP 是 VS Code 能够快速流行的重要原因；其核心思想是编辑器可以调用计算机上运行的外部服务来获取代码库的有用信息。LSP 提供了许多有用的功能，如转到定义和引用、突出显示代码错误、显示变量或类的文档等。它甚至可以帮助进行代码格式化和语法高亮。

根目录是 LSP 推断出的当前打开文件所属项目的"主目录"。LSP 如何确定根目录取决于具体的编程语言（和语言服务器）。例如：

- 在 JavaScript 或 TypeScript 项目中，它可能会在父目录中搜索 package.json 或 tsconfig.json 文件，找到后，将此文件所在的目录视作根目录 
- 在 Python 项目中，它可能会寻找 pyproject.toml 或 poetry.lock
- Rust 项目使用包含 Cargo.toml 的目录
- 某些 LSP 可能只是将包含 .git 文件夹的目录视为项目工作空间的"根目录"

根目录和当前工作目录（cwd）经常是同一个目录，这其实很好理解，因为我们平常开发项目时，第一步通常就是先进入项目目录，然后再打开 Neovim。所以自然而然，当前工作目录就会和项目的根目录重合。

这种自动根目录功能在处理多个项目时非常有用。不需要像前面讨论的那样使用 lcd，你可以直接使用 :e 或我们接下来要讨论的文件查找扩展来打开另一个项目中的文件。然后如果你使用 <Space><Space> 或 <Space>ff 调用"查找文件（根目录）"命令，它会在你刚刚打开的文件所在的根目录中查找其他文件。

然而，有时这可能会造成困扰，特别是在处理单体仓库（monorepo）或根目录出现在意外位置时。例如，我有一个普通的 Svelte 项目，其中包含一个 package.json 文件。这个项目使用 Cypress 进行测试，而 Cypress 文件夹包含一个 tsconfig.json 文件，这导致 TypeScript 语言服务器将其解释为一个单独的根目录。所以当我在处理某个 Cypress 测试文件并按下 <Space><Space> 时，根目录被认为是 Cypress 文件夹，我只能打开其他 Cypress 测试。但通常我想要做的是打开主文件夹中的源文件来查看测试失败的原因。在这种情况下，我必须按 <Escape><Escape> 退出 Telescope 选择器，然后按 <Space>fF 以当前工作目录模式打开选择器。

## [4.3. Fzf.lua](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-4/#_fzf_lua)

LazyVim 最近推出了一个可选的新选择器功能，作为 Telescope 的替代方案。这让我这个写教程的人更头疼了！虽然两者很相似，但差异足够大，需要分开来说明。

Fzf.lua 的主要优势，据说在于它为习惯使用命令行 fzf 工具的用户提供了一个"熟悉"的界面。Fzf 是一个很实用的命令行工具，它可以通过模糊匹配的方式，只需输入几个字符就能在复杂的文件系统中切换目录或打开文件。我用了好几年，确实很推荐。不过说实话，我个人并不太在意编辑器是否要和命令行工具保持完全一致的体验，所以这个优势对我来说并不是特别有说服力。

另一个推荐使用 Fzf.lua 的理由是它比 Telescope 性能更好。虽然在我的电脑上没怎么感觉出差别，但如果你觉得 Telescope 有点卡顿，可以试试 Fzf.lua。

不过 Fzf.lua 也有一些缺点：

1. 主要缺点是它实际上是在 Neovim 的终端窗口中运行的，这导致普通模式的行为很奇怪。特别是按 Escape 键时，它会直接关闭选择器，而不是像 Telescope 那样进入输入区域的普通模式。
2. 第二个缺点是 Fzf.lua 的插件生态没有 Telescope 那么丰富。实际使用中，从 Telescope 换到 Fzf.lua 我只会想念一个插件，但如果你是 Telescope 的重度用户，可能会发现 Fzf.lua 的选项相对较少。

如果你想尝试 Fzf.lua，你需要了解 Lazy Extras。我会在下一章详细介绍 Lazy Extras，简单来说它们是一些可以通过单个按键启用的可选插件配置。要启用 Fzf.lua，你需要：

1. 输入 :LazyExtras 然后按回车
2. 将光标移动到包含 editor.fzf 的那一行
3. 按 x 键安装这个扩展
4. 等待相关插件安装完成
5. 重启 Neovim

完成上述操作后，Telescope 会被禁用，转而启用 Fzf.lua。当你打开选择器时，会看到一个略有不同的布局：

<img src="mymedia\fzf-dark.png" alt="fzf dark" style="zoom:50%;" />

主要的区别是在 Fzf.lua 中，输入区域位于左侧顶部，而不是像 Telescope 那样在底部。

选择器的基本操作和 Telescope 类似，我只重点说明一下不同之处。最大的区别就是前面提到的，基于终端的普通模式行为比较特别。如果你想从输入区域进入普通模式，需要按一个很奇怪的组合键：先按 Control-\，再按 Control-n。进入普通模式后，你可以在窗口中导航，大多数快捷键的行为都和你期望的普通模式一样。

最明显的例外是 Seek 模式的行为和 Telescope 不同。如果你想在 Fzf.lua 中通过标签跳转到某一行，需要使用不太好记的 Control-x 快捷键。

Fzf.lua 默认配置了几个其他快捷键，按 F1 可以看到它们的帮助菜单。我经常使用的只有几个：

- Control-a 和 Control-e（这两个是类 Emacs 风格的烦人快捷键）：跳到输入区域的开头或结尾
- Control-d 和 Control-u：滚动结果窗口

在本书剩余部分，我会默认你使用的是 Telescope 而不是 Fzf.lua，但如果两者之间有明显的差异，我会特别说明。现在，让我们转向一个完全不同的文件选择体验。

## [4.4. Neo-tree.nvim 插件](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-4/#_the_neo_tree_nvim_plugin)

Neo-tree 创建了一个左侧边栏的文件浏览器，这种体验对许多现代 IDE 和编辑器的用户来说应该很熟悉。虽然和其他那些环境一样，Neo-tree 支持鼠标操作，但它更注重键盘交互，一旦你掌握了"Neo-tree 模式"，使用起来会更快。

我想先坦白一点：我个人并不使用 Neo-tree。我觉得我们刚才讨论的文件选择器是打开文件最快的方式，而当我需要操作文件系统时，我更喜欢使用 mini.files（我们将在本章后面讨论）。我更喜欢 mini.files 的主要原因是它使用的快捷键和 Vim 普通模式相同。模式很好，但是没必要搞太多！

不过，我猜很多读者会更喜欢 Neo-tree 提供的这种熟悉的树状视图体验。由于这个插件是 LazyVim 的默认配置，我想在本书中给它一个公平的介绍。

让我们先用 Space-e 快捷键打开 Neo-tree，这里的助记符是"e for Explore"（e 代表浏览）。如果你打开 Space 模式菜单，你会看到和模糊选择器一样，有两种方式可以打开 Neo-tree 浏览器：

- Space-e：在根目录下打开 Neo-tree
- Space-E：在当前工作目录下打开 Neo-tree

"根目录"和"当前工作目录（cwd）"的含义和我们在上一节讨论的一样。你会注意到小写字母和大写字母之间的一致关系：

- Space-ff 和 Space-e 都是打开根目录
- Space-fF 和 Space-E 都是打开当前工作目录

> 要隐藏 Neo-tree 浏览器窗口，只需在窗口可见时再次按 Space-e，或者在窗口处于焦点状态时按 q 键即可。

当打开浏览器时，它会显示相关目录中的所有文件和文件夹。所有文件夹都是折叠的，除了当前正在编辑的文件所在的文件夹（如果有的话）会被展开。比如，当我编辑这个文件时，我的 Neo-tree 看起来如下：

<img src="mymedia\neo-tree-dark.png" alt="neo tree dark" style="zoom:50%;" />

光标位于我当前正在编辑的文件上（左侧的page.svx上）。我可以使用常见的 j 和 k 键上下移动光标。

文件夹都被收集在视图的顶部。如果你将光标移动到这些文件夹上，你可以按回车键查看文件夹内的文件。同样，如果移动到某个文件上，也可以用回车键在当前 Vim 窗口中打开该文件。

你也可以通过鼠标双击来展开和折叠文件夹以及打开文件，但我猜一旦你学会了正确的键盘导航方式，你就不会想用鼠标了。

说到键盘导航，是的，如果要浏览的文件很多，用 j 和 k 上下移动可能会很慢。我们在第三章讨论过的所有命令都可以加上数字用来加快移动速度。例如，输入 10j 只需要三次按键就能让光标向下移动 10 行，而不是要按 10 次 j 键。使用 Control-d 或 Control-u 可以上下滚动树状视图。最有趣的是，即使 Neo-tree 当前没有获得焦点，也可以使用 s（seek）键来快速定位到 Neo-tree 视图中的任意一行。

Neo-tree 会将根目录或当前工作目录显示为最顶层目录。如果你需要向"上"导航到更高层级的目录，你需要使用退格键。

> 退格键在 Vim 中通常被写作 BS，所以如果你看到某个快捷键绑定或说明提到 BS 可以做某事，这不是在开玩笑（bullshit）！它就是指退格键。

除了导航和打开文件，你甚至可以使用 Neo-tree 对文件系统进行修改。例如，要删除一个文件，你可以将光标移到该文件上并按 d 键。这时会弹出一个窗口询问你是否确定。按 y 然后回车确认即可：

<img src="mymedia\neo-tree-delete-dark.png" alt="neo tree delete dark" style="zoom:50%;" />

要添加文件或文件夹/目录，使用 a 键并输入新名称。在名称末尾加上斜杠（/）表示创建文件夹。你也可以在 Neo-tree 浏览器中使用 A 键来添加文件夹，这样就不用手动输入末尾的斜杠了。

r 键可以用来重命名光标下的文件或文件夹。

要复制或移动文件，你可以使用 Neo-tree 的伪剪贴板。之所以说是"伪"剪贴板，是因为你不能用它来复制文件然后粘贴到比如 MacOS Finder 或 Windows 资源管理器中；它只能用于 Neo-tree 内部的操作。

如果想剪切文件并将其移动到树中的其他位置，使用 x 命令。如果想复制文件，则使用 y 键。y 的助记符是 yank（抽出），实际上这和在普通编辑器中复制文本用的是同一个键。要完成移动或复制操作，你需要导航到目标文件夹，然后使用 p 键（你可能还记得这代表"put"或"paste"，即放置或粘贴）。

Neo-tree 还有一个"过滤"模式，我觉得这个模式相当笨拙；它实际上只是在一个较小的窗口中模仿 Telescope/Fzf.lua 选择器的功能，所以我建议你还是使用你选择的选择器。如果你想使用 Neo-tree 的过滤模式，可以用 / 键进入，然后输入一些字符来将搜索结果限制在匹配这些字符的文件中。然后使用上下箭头键来浏览列表（这里不能用 j 和 k 键，因为你处于一种类似插入模式的上下文中）。

Neo-tree 还有很多其他很酷的功能。比如，我们稍后会介绍它在缓冲区、git 和符号导航方面的用途。在此期间，你可以在 Neo-tree 窗口获得焦点时按 ? 键（助记符是"问问题寻求帮助"）来获取概览，或者输入 :help neo-tree 来获取详尽的信息（就像从消防水管里喝水一样，量巨大）。

## [4.5. 替代方案 - Mini.files](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-4/#_the_mini_files_alternative)

正如我提到的，我实际上并不使用 Neo-tree 来进行文件导航。我觉得它给人一种"格格不入、不像 vim"的感觉。对我来说，它就像是一个恰好嵌入到 Neovim 窗口中的完全独立的体验。话说回来，我也不喜欢 VS Code 及其模仿的/被模仿的编辑器中的树状视图侧边栏体验，所以可能树状视图就是不适合我。

这些都只是我的个人观点，文本编辑器的黄金法则之一就是"所有观点都是有效的"（否则就会引发战争）。很多 Neovim 用户都很喜欢 Neo-tree，如果它符合你的思维模式，你就应该使用它。

话虽如此，显然不只是我有这样的想法，因为 LazyVim 还可选地提供了另一种文件管理体验，一个叫做 mini.files 的插件。这个插件默认是禁用的。

> Mini.files 是 mini.nvim 套件中的一部分，这是一组相对零散的 Neovim 软件包。这些插件之间相互独立，提供了许多本应该随 Neovim 一起发布的常用功能。有时候，mini.nvim 插件可能不如它们模仿的其他插件，但很多时候它们都是同类中最好的。Mini.files 并不是 LazyVim 附带的唯一一个 mini.nvim 插件，我们稍后会介绍其他插件。

Mini.files 文件管理器有点像是 Neovim 原生版本的分栏视图，这种视图在 macOS Finder 等文件管理器中很受欢迎。我喜欢它的主要原因是编辑目录列表就像编辑普通文本缓冲区一样。我不需要记住 a 在普通模式下表示"之后"，而在资源管理器模式下却表示"添加文件/文件夹"。相反，在 mini.files 中，我使用 o 键来"在当前行下方创建新行"，然后在 Neovim 的插入模式下输入新的文件名。之后，我让 mini.files 同步我的更改，它就会为新行创建对应的文件。

要使用 mini.files，你需要像启用 FZF 选择器那样将其作为 Lazy Extra 启用。具体步骤是：

1. 输入 :LazyExtras<Enter>
2. 将光标移动到包含 mini.files 的那一行（使用 Seek 模式最快）
3. 按 x 键来安装这个 Extra（额外功能）
4. 等待插件安装完成
5. 重启 Neovim

### [4.5.1. 使用 Mini.files](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-4/#_using_mini_files)

安装完成后，你可以使用 <Space>fm 和 <Space>fM 来显示 mini.files 视图。默认情况下，这些视图与我们在 Telescope、Fzf.lua 和 Neo-tree 中看到的 cwd/root 结构略有不同。它们在 <Space>f 菜单中的显示如下：

```tex
m -> Open mini.files (Directory of Current File)
M -> Open mini.files (cwd)
```

默认的 mini.files 配置没有在根目录打开的选项。我喜欢能够打开当前打开文件所在的目录，但我不想失去打开当前项目根目录的功能。我会在第 5 章介绍如何解决这个问题。

mini.files 菜单不是以侧边栏的形式显示，而是以并排的窗口列（称为 Miller 列）的形式显示。例如，当我在这本书的当前工作目录中打开 mini.files 时，会出现如下显示：

<img src="mymedia\mini-files-dark.png" alt="mini files dark" style="zoom: 80%;" />

左侧面板显示当前工作目录，中间列显示 book 目录的内容，其中我的光标当前位于第 4 章。右侧列显示第 4 章目录的预览，其中只包含一个文件。

与 mini.files 的交互非常类似于与标准 vim 窗口的交互。你可以使用 j 和 k 键上下移动光标。如果光标停在文件夹上，该文件夹的内容会立即显示在右侧；如果停在文件上，你会看到该文件的预览。

如果你想"进入"文件夹以与其内容交互，只需按 l 键向"右"移动。

同样，按 h 键将会从当前文件夹"退出"。如果光标在最左侧列，向左移动将打开一个新的最左侧列，这样你可以根据需要一直导航到文件系统的根目录。

要在当前活动的 Neovim 窗口中打开文件，请再次在该文件上按 l 键。这里的行为可能有点出人意料：文件会在 mini.files 视图下打开，但不会隐藏文件菜单。这允许你在关闭导航器之前打开多个文件，可以使用 q 键关闭导航器。

与 Neo-tree 相比，mini.files 的优美之处在于这些小窗口的行为就像普通编辑器一样，你已经习惯的所有导航功能都可以使用。例如，可以使用 Seek 模式导航到文件。按 s 键，然后输入你想搜索的任意字符。任何与输入字符匹配的项都会被标记，你可以通过输入指示的标签跳转到它们。

甚至修改文件系统也和编辑普通缓冲区完全一样。我们还没有真正介绍编辑（我和你一样惊讶），但这里有一个快速概述：

- 要重命名文件或文件夹，导航到包含它的行，然后进入插入模式来更改或添加文本。
- 删除文件或文件夹使用命令 dd，这是在普通 Neovim 窗口中删除整行文本的键绑定。
- 使用 yy 复制文件或文件夹，这是复制（"yank"）一行文本的命令。
- 使用 p 放置/粘贴已删除或复制的文件。

我们将在第 6 章讨论这些命令和更多内容。主要的一点是，你将来学习的几乎任何导航或编辑命令都可以在 mini.files 中使用。

**保存文件系统更改：**
使用这些键绑定进行的任何修改实际上不会保存到文件系统中，直到你按下 = 键，这是一个（罕见的）mini.files 特有的键绑定。我认为它的含义是"使文件系统等于我输入的内容"。这会弹出一个小窗口，告诉你 mini.files 想要代表你执行的操作，比如删除、移动、重命名或复制文件。你可以用 y 或 n（当然是表示 yes 或 no）来确认或拒绝这些更改。

我建议你同时尝试使用 Neo-tree 和 mini.files，直到你能决定更喜欢哪一个。最终，你会得出以下结论之一：

1. 你更喜欢 Neo-tree，不需要 mini.files。在这种情况下，重新进入 LazyExtras 模式，用 x 键禁用 mini.files。
2. 你在某些交互中使用 Neo-tree（可能是我们还没有介绍的功能，比如导航 git、缓冲区或符号），在其他情况下使用 mini.files。在这种情况下，你可能对 mini.files extra 的默认 LazyVim 配置感到满意。
3. 你和我一样特别，完全不想使用 Neo-tree，只想使用 mini.files。关于如何禁用插件将在下一章讨论。

## [4.6. 总结](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-4/#_summary_4)

在本章中，我们学习了在 LazyVim 中打开文件和与文件系统交互的四种不同方式：Telescope、Fzf.lua、Neo-tree 和 mini.files。每种方式都提供了不同的机制来打开和管理文件，你会发现其中一些方式相比另外的更适合你。

作为学习这些文件系统工具的副作用，我们还简单预览了如何配置插件和安装 LazyVim extras。我们将在下一章中更详细地讨论这些内容。

# [第五章 配置与插件基础](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-5/#_configuration_and_plugin_basics)

在第一章中，我已经多次提到了插件，你也见识过了 Lazy.nvim 插件管理器的实际运用。LazyVim 采用了一种独特的多层级插件管理方式，虽然需要一些解释，但在实际使用中非常优雅。

通过安装插件，你可以让 Neovim 实现一些默认情况下无法实现的功能。插件通常使用 Lua 或 VimScript 编写，不过通过 Neovim 的远程插件架构（即 RPC：Remote Plugin Architecture 调用机制），也支持使用其他编程语言。

```tex
-- init.lua
vim.g.python3_host_prog = '/path/to/python' -- 指定 Python 解释器

-- 过程：
Neovim 
  ↓ RPC 请求
插件主机(Host Process)
  ↓ 执行对应语言代码
返回结果
```

## [5.1. LazyVim 中的三类插件](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-5/#_the_three_categories_of_plugins_in_lazyvim)

LazyVim 中最简单的一类插件，是由 LazyVim 本身预装提供的。你已经使用过其中的许多插件了。有些插件（如 Neo-Tree、Telescope 和 Lazy.nvim）提供了自定义的用户界面组件供交互使用。另一些插件（如 flash.nvim 和 which-key）则提供了新的命令或模式。还有一些插件则在后台静默运行，比如自动匹配括号或标签，以及绘制缩进参考线。

这些预装插件在 LazyVim 中都配置了（通常来说）合理的默认设置。由于它们集成得很好，自定义这些默认设置是可行的，不过有时需要一些技巧，我们会在本章和后续章节中介绍这些内容。

第二类插件是"Lazy Extras（懒加载扩展）"。这些插件默认是不启用的，但如果你需要的话，只需几次按键就能启用。Lazy Extras 的存在使得安装流行插件变得容易，而且它们的配置能保证与 LazyVim 自带的其他插件和谐共存。

> （ethan）对于 Lazy Extras，我更偏向于理解为，是一个**功能**，而不是**插件**。一项 Lazy Extras，代表着启用某一个功能，这些个功能会安装、启用一个或多个插件，并按照 Lazyvim 预设的配置来工作。

第三类是 LazyVim 不直接支持的第三方插件。你需要从头开始配置这些插件，并且要自己确保它们的快捷键绑定和视觉效果不会与 LazyVim 管理的插件发生冲突。在非 LazyVim 的配置中，所有插件都属于这一类，随着插件的更新迭代或逐渐停用，维护这些插件可能会成为一个令人头疼的问题。而在 LazyVim 中，这类插件相对较少，因此整体体验要愉快得多。

让我们通过三个文件管理插件的具体例子来说明，其中两个我们在上一章已经讨论过：

- Neo-tree.nvim

  是 LazyVim 预装的默认启用插件。LazyVim 对 Neo-tree 的默认配置不会与其他 LazyVim 插件产生冲突。不过，如果你想调整这些配置，可能需要做一些额外的工作。

- Mini.files

  作为 Lazy Extra（懒加载扩展）提供，基本上只需"一键"（既然我们在讨论 Vim，那就是一次按键！）就能安装，并且能够很好地与 LazyVim 配合使用。

- Oil.nvim

  是一个文件系统管理的替代插件，LazyVim 并不直接支持它。你可以通过几行配置在 LazyVim 中安装它，但它的设置不像 mini.files 那么简单，而且无法保证不会出现需要你自己解决的冲突。

从 Neovim 的角度来看，这些插件都是完全一样的，因为 Neovim 只认识第三方插件。LazyVim 只是提供了一些额外的结构，这些结构是你在使用插件时需要考虑的。通常这种结构会让事情变得更简单，但有时也会带来一些额外的麻烦。

## [5.2. Lazy Extras](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-5/#_lazy_extras)

在上一章中，我介绍了如何使用 Fzf.lua 和 mini.files，但对安装说明讲解得比较简略。现在我们将深入探讨这个话题。

你可以在仪表盘界面按 x 键来访问 Lazy Extras 模式。如果你当前不在仪表盘界面，需要先进入命令模式（按 :），然后输入 LazyExtras 并按回车确认命令（顺便说一下，你可以随时通过输入 :Dashboard 命令来显示仪表盘）。

无论通过哪种方式，你都会看到一个可安装插件的列表。在我的设置中，它看起来是这样的：

<img src="mymedia\lazy-extras-dark.png" alt="lazy extras dark" style="zoom:50%;" />

我目前已经安装了十多个扩展，主要是为了支持我涉猎的各种编程语言。你可以使用所有标准导航命令（如 j、k 或 s）来浏览这个文件。

无论你通过什么方式到达那里，一旦你的光标位于你想要安装的扩展（比如 editor.mini-files）所在行，只需按 x 键即可安装该扩展。如果你想要卸载它，操作方式相同：移动到相应的行（现在在"已启用扩展"列表下），再按 x 键禁用该扩展。这里的记忆方式是 x 代表"Extra（扩展）"。

你可能需要退出并重启 Neovim，让 Lazy.nvim 识别到扩展已安装并同步其依赖项。

当我们在 LazyExtras 界面时，我建议为你最常用的编程语言启用 lang.* 扩展。你还应该安装"推荐插件"部分中的所有插件（它们旁边有星号图标），但以下除外：

- ui.mini-animate，除非你的机器比我的性能好得多。这个插件在我的 2020 年款 Intel IMac Pro 上非常卡顿。
- editor.fzf，除非你已经决定更喜欢它而不是 Telescope（就像我们在第 4 章讨论的那样）。

在你完成本书的阅读或有机会研究它们之前，我建议不要安装其他非推荐的扩展。否则，它们可能会以我无法预见的方式改变行为。

你可以访问 [https://lazyvim.org](https://lazyvim.org/) 并点击左侧菜单栏的"Extras"菜单项来获取每个扩展的更多信息。它包含了每个扩展安装的插件列表的链接，以及 LazyVim 为该扩展提供的配置。

## [5.3. 禁用内置插件](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-5/#_disabling_a_built_in_plugin)

迟早你会想要编辑你的 LazyVim 配置。虽然默认配置很棒，但可能无法 100% 完全匹配你的个人需求。

尽管 LazyVim 的大多数默认插件都是不需要考虑就该保留的，但你可能会发现有一两个插件是你不需要的。在大多数情况下，这并不重要，因为 LazyVim 只会在你实际使用插件时才加载它们，所以你可以直接忽略那些与你无关的插件。

我唯一禁用的 LazyVim 插件是 Neo-tree。我会展示如何做到这一点，你可以据此调整来禁用任何其他你想要禁用的插件。

首先我想介绍一下 LazyVim 配置目录。你可以在仪表盘上直接按 c 键打开配置目录。或者你可以随时使用 Space 模式通过 Space+fc（"Find Config Files"的意思）来访问配置文件。

这将在你的文件选择器中加载 LazyVim 配置文件夹。这个文件夹通常位于 $HOME/.config/nvim。Neovim 默认加载 $HOME/.config/nvim/init.lua，如果你不使用 LazyVim，这就是你进行所有配置的地方。

使用 LazyVim 时，init.lua 只是使用 Lua 的 require 语句来包含 LazyVim 配置基础架构。**通常你不需要修改这个文件**，即使大多数第三方插件的安装文件都假设你的配置在该文件中。相反，请按照本章所述的"LazyVim 方式"进行操作。

除了基本的 init.lua 外，LazyVim 在配置目录中还放置了一些配置文件和文件夹结构。

目前，我们主要需要知道的是，lua/plugins 子目录中的任何 Lua 文件都会被 LazyVim 自动加载，不管它们的名字是什么。我在这个文件夹中有几个不同的文件用于自定义配置。

我把存放禁用插件的文件命名为 disabled.lua。创建这个文件最简单的方法是打开一个现有的配置文件，然后使用 Neo-tree 或 mini.files 在同一文件夹中创建新文件，就像第 4 章中描述的那样。

当我在 lua/plugins 目录中创建 disabled.lua 文件时，我的本意是在其中收集所有我不想要的 LazyVim 插件，因为我假设 LazyVim 可能不完全符合我的需求。但实际上，这个列表非常短！这个文件的内容很简单：

```lua
return {
  { "nvim-neo-tree/neo-tree.nvim", enabled = false },
}
```

如果 LazyVim 默认启用的其他插件中有你不想使用的，只需遵循相同的语法即可。每个 Lua 表中的第一个参数是包含你想要禁用的 GitHub 仓库（包含所有者）的字符串。第二个参数是设置 enabled = false。就这么简单！

> 你迟早会在插件配置文件开头忘记写 return 语句。现在你知道要注意这一点了。

如果你不懂 Lua 语言...说实话，不用担心。我从没有正式学习过它，但是通过潜移默化，我已经掌握了足够维护我的 Neovim 配置的知识。

如果你比我更谨慎，你可以输入 :help lua 来阅读 Neovim 官方文档。然后查看 :help lua-guide-api 来了解 vim 特有的 API。

## [5.4. 修改键位绑定（示例）](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-5/#_modifying_keybindings_example)

说到快捷键绑定，这是我在使用 LazyVim 时为数不多不太满意的地方，虽然这并不完全是 LazyVim 的问题。我总是搞不清楚应该在哪里定义这些快捷键！

配置快捷键绑定有三个可能的位置，具体取决于插件的配置方式：

1. 在 .config/nvim/lua/config/keymaps.lua 文件中。这里通常用于配置或修改那些与插件无关的快捷键，主要是用来修改 Neovim 核心功能或 LazyVim 的功能。
2. 在传递给插件的 Lua 表（在 Lua 中，"表"类似于其他动态语言中数组和记录或字典的组合）的 keys 字段中。这里通常用于设置插件的全局普通模式快捷键绑定。这就是我们将要在 mini.files 中使用的方式。
3. 在传递给插件配置的 opts（选项）参数中。每个插件的选项格式都是特定的，但很多插件更倾向于通过选项来为你设置快捷键，而不是让你自己去映射。这种情况在快捷键定义了不同的"模式"，或者只在插件当前打开或激活时才生效时特别常见。我也会用 mini.files 来演示这一点。

为了说明这一点，我想要"修复" mini.files 没有"在根目录打开"选项的问题。虽然我喜欢"在当前文件所在目录打开"的选项，但我也想要能够在根目录打开的功能。

> 请记住，根目录是指当前项目的最顶层目录，它通常由一些特定语言的文件（比如 package.json 或 Cargo.toml）的存在来确定。而 cwd（current working directory，当前工作目录）是编辑器的当前工作目录。

既然我已经禁用了 Neo-tree，我打算把 Space e 和 Space E 这两个快捷键重新分配给 mini.files，然后把现有的 Space fm 快捷键重新映射为打开根目录的功能，这样我就能使用全部三个命令了。当然，如果你觉得其他快捷键更符合你的使用习惯，或者你还在使用 Neo-tree，你可以选择不同的快捷键绑定。

我通过在 .config/nvim/lua/config/plugins/ 目录下创建一个名为 extend-mini-files.lua 的新文件来配置 mini.files。和 disabled.lua 文件一样，这个文件的名字可以随意取，只要确保它位于 plugins 目录下就行。

我习惯给所有用来修改 LazyVim 默认配置的文件名加上 extend 前缀。这样当我用 mini.files 或 Telescope 查看目录时，就能很容易地把它们和我额外安装的非 LazyVim 插件区分开。

在这个新文件中，我使用了以下代码：

```lua
return {
  "echasnovski/mini.files",
  keys = {
    {
      "<leader>e",
      function()
        require("mini.files").open(vim.api.nvim_buf_get_name(0), true)
      end,
      desc = "Open mini.files (directory of current file)",
    },
    {
      "<leader>E",
      function()
        require("mini.files").open(vim.uv.cwd(), true)
      end,
      desc = "Open mini.files (cwd)",
    },
    {
      "<leader>fm",
      function()
        require("mini.files").open(LazyVim.root(), true)
      end,
      desc = "Open mini.files (root)",
    },
  },
}
```

我是通过从 LazyVim 网站上提供的 Telescope find files 和 Neo-tree 插件的默认配置中提取相关函数调用来构建这段代码的。

为了满足 Lazy.nvim 的要求，我们需要返回一个用花括号包裹的 Lua 表。Lua 表的特点是可以同时作为数组和字典使用。在这个例子中，表的第一个元素是字符串 "echasnovski/mini.files"。它没有指定键名，所以可以理解为一个"位置参数"（从 GitHub 上哪里下载）。

表中的第二个元素更像是一个"命名参数"，它通过 keys 这个名字来索引，其值是另一个 Lua 表。不过，这第二个表更像是一个包含三个值（三个独立的 Lua 表）的"数组"，因为它没有命名索引。

需要注意的是，keys 字段会与 LazyVim（extras）为 mini.files 提供的默认配置中的 keys 进行合并。如果出现冲突（比如 space fm），**我们的配置会覆盖默认值**。

这是 LazyVim 的一个强大特性，让我们可以使用 LazyVim 提供的托管配置，同时根据需要进行覆盖。早期的 Neovim 发行版通常没有这么灵活，所以你要么只能使用他们的配置，要么就得复制整个配置然后修改，这让更新变得非常麻烦。

需要说明的是，keys 是 LazyVim 的概念（严格来说，它其实是底层的 Lazy.nvim 插件管理器的一部分）。任何插件配置都可以有一个 keys 数组表，这些键位绑定会与 Neovim 的默认键位绑定、LazyVim 的键位绑定、你的自定义全局键位绑定以及其他插件的键位绑定进行合并。

是的，这确实可能会产生很多冲突，这也是为什么我非常感激 LazyVim 帮我处理了大部分配置工作！

### [5.4.1 键位配置项的结构](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-5/#_structure_of_a_keys_entry)

keys 表中的每一项都是一个包含（在这个例子中是）三个字段的 Lua 表。前两个字段是位置参数，分别表示键位绑定名称和当这个键位被触发时要调用的 Lua 回调函数。第三个字段是一个命名字段 desc，它提供了一个字符串描述，这个描述会显示在 Space 模式菜单中。

第一个配置项中的键位序列使用的是标准的 Vim 语法。这里的 <leader> 是一个古老的 Vim 概念，它允许你配置哪个键作为自定义键位绑定的前缀。在 LazyVim（实际上对大多数现代 Neovim 用户来说也是如此）中，leader 键被设置为 <Space>。特殊键需要用尖括号来指示给 Vim 的键位绑定引擎，所以你经常会看到像 <Space>、<Right>、<Left> 或 <BS> 这样的表示方法。

在 <leader> 字符串之后，我们需要包含所有需要按下的额外按键。对于简单的情况，我们用 e 和 E 来替换我们之前禁用的 Neo-tree 键位绑定，改为新的 mini.files 键位绑定。第三个键位绑定稍微复杂一些，其中的 f 表示这个动作将在 Space 模式的 file/find 子菜单中可用，而 m 则指示了这个菜单中将使用的字母。

对于回调函数，我们使用 Lua 函数，它们总是以 function 开始，以 end 结束。这些都是匿名（未命名）函数，它们的括号中不接受任何参数。在函数体内，我们调用特定的代码来按照我们想要的方式打开 mini.files。其中的两个函数，是我直接从 LazyVim 的默认 mini.files 配置中复制过来，第三个则是我通过组合 Neo-tree 和 mini.files 配置中的代码拼凑而成。LazyVim 全局对象是一个很方便的库，包含了许多用于辅助配置的实用函数。LazyVim.root 函数用于查找项目的根目录，并返回一个字符串，我们将这个字符串传递给 mini.files.open。

### [5.4.2. Mini.files 选项自定义](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-5/#_customizing_mini_files_options)

正如我提到的，keys 表会与 LazyVim 为 mini.files 配置的默认 keys 表合并。类似地，大多数 Neovim 插件都可以通过一个 opts 表来配置，这个表包含了该插件的特定自定义配置。如果你提供了一个 opts 表，它会与 LazyVim 的默认配置（如果存在的话）合并。

你需要阅读每个插件的文档（通常可以在 Github 上找到，也可以通过 :help plugin-name 查看）来了解该插件具体有哪些可用的选项。你还需要查看 LazyVim 为该插件设置的默认配置，以便理解它们将如何合并。

在我的情况下，我向 mini.files 传递了以下 opts 数组：

```lua
return {
  "echasnovski/mini.files",
  keys = {
    -- the keybindings from above
  },
  opts = {
    mappings = {
      go_in = "<Right>",
      go_out = "<Left>",
    },
    windows = {
      width_nofocus = 20,
      width_focus = 50,
      width_preview = 100,
    },
    options = {
      use_as_default_explorer = true,
    },
  },
}
```

mini.files 中的 mappings 表用于覆盖在 mini.files 视图打开时生效的默认键位映射。这与我们之前定义的用于打开 mini.files 的全局键位映射是不同的。在我的情况下，我将 go_in 和 go_out 映射到方向键而不是 h 和 l，这是因为我之前提到的左手 Dvorak Kinesis 键盘的特殊性。我不建议你做这样的更改；对于大多数人来说，h 和 l 会更好用。

window 选项的设置是因为我使用的是 32 英寸的 6k 显示器，这意味着我可以设置比正常更大的资源管理器列宽。关于这些和其他选项的更多信息，请参考 :help mini.files。

现在你对在 LazyVim 中配置插件有了一些了解。与从头开始配置插件相比，这种方式既有更简单的一面，也有更复杂的一面：

更简单是因为你只需要修改非默认值，而不是设置整个配置，并且 LazyVim 提供了合理的默认设置。

但也更复杂，因为你有时需要考虑选项和键位绑定是如何合并的，如果一开始就有一个完整的配置对象，就不需要考虑这个问题了。对于那些在 LazyVim 中有复杂默认配置的插件来说，这种合并可能会变得相当棘手。我们稍后会看到一些例子。

## [5.5. 修改现有选项](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-5/#_modifying_existing_options)

当我们想要修改 LazyVim 中的插件设置时，有时候事情没那么简单。LazyVim 默认的"合并"方式可能不够灵活，特别是当插件的设置涉及到函数而不是简单的配置项时。

为了解决这个问题，在 Lazy.nvim 的插件配置中，opts（选项）不一定要是一个固定的配置表，它可以是一个函数。这个函数会接收到 LazyVim 原本的配置，你可以在这个函数里直接修改这些配置。

举个具体例子： nvim-cmp 是一个在你输入代码时提供自动补全提示的插件。它很好用，但在 LazyVim 的默认设置中，按回车键会选中补全建议。对我来说这很烦人，因为我在写文章时经常需要按回车换行，但每次按回车都可能不小心选中了一个我不想要的补全。

LazyVim 的文档里提供了几种修改这个行为的方法，nvim-cmp 的说明文档里也有一些其他解决方案。下面我会展示我是怎么修改这个设置的：

```lua
return {
  {
    "hrsh7th/nvim-cmp",
    opts = function(_, opts)
      local cmp = require("cmp")
      opts.mapping = vim.tbl_extend(
        "force",
        opts.mapping,
        {
          ["<Right>"] = cmp.mapping.confirm({ select = true }),
          ["<CR>"] = function(fallback) cmp.abort() fallback() end,
        }
      )
    end,
  },
}
```

首先，这里说的 opts 函数会接收到 LazyVim 默认的配置作为它的第二个参数。就像是你收到了一份已经写好的配置菜谱，现在你要在上面做一些修改。

我用了 Neovim 提供的 tbl_extend 函数来修改这些配置。具体做了两件事：

1. 添加了一个右方向键（<Right>）来确认补全建议 - 这个设计是参考了 fish shell 的操作方式
2. 把回车键（<CR>）的功能改成了取消补全 - 这样按回车就不会选中补全建议了

说实话，这种改配置的方式确实比直接从头写一个完整的配置要麻烦一些。就像是你想改一道菜的做法，与其改别人的菜谱，不如直接写一个自己的菜谱来得简单。

但是！如果要我从零开始写所有配置，那就更麻烦了。这就像是与其修改大厨的菜谱，自己从头开始研究怎么做菜要困难得多。

所以我觉得这是个值得的权衡 - 因为 LazyVim 在很多地方的配置都比我自己写的要好。就像是虽然要改动大厨的菜谱有点麻烦，但至少保证了菜的基本味道不会差。

## [5.6. 安装第三方插件](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-5/#_installing_third_party_plugins)

安装第三方插件其实和配置 LazyVim 自带的插件差不多，但有一个好处：你不用担心你的设置会和默认配置打架（因为根本就没有默认配置需要合并）。

具体步骤很简单：

1. 在 plugins 目录下创建一个新的 Lua 文件
2. 文件名最好能反映这个插件是做什么的
3. 在文件里，你要返回一个 Lua 表（table），这个表里：
   - 第一项必须是插件的 GitHub 地址和名字
   - 后面可以跟上其他配置，比如 opts 和快捷键设置等

来看个实际的例子： 我喜欢用 guess-indent.nvim 这个插件，它能根据我正在编辑的文件内容自动设置缩进宽度。这个插件是由 GitHub 用户 nmac427 维护的。

所以我的 plugins/guess-indent.lua 文件是这样写的：

```lua
return {
  "nmac427/guess-indent.nvim",
  opts = {
    auto_cmd = true,
    override_editorconfig = true
  },
}
```

opts 表里该放什么完全取决于插件本身的要求。比如我看了 guess-indent.nvim 的说明文档后，发现有两个选项是我想设置的。

现在大多数 Lua 插件的文档都会告诉你要调用一个 setup 函数，并传入一个包含配置的 Lua 表。如果你要设置的插件没有专门的 Lazy.nvim 使用说明也别担心：你只要把原本要传给 setup 函数的那些配置放到 LazyVim 插件管理器的 opts 里就行了。

我推荐一个很好用的第三方插件：chrisgrieser/nvim-spider。这个插件很巧妙地改进了 w、e 和 b 这些命令，让它们能够在 CamelCase 和 snake_case 的单词内部导航。

我在 plugins 目录下创建了一个 nvim-spider.lua 文件，内容如下：

```lua
return {
  "chrisgrieser/nvim-spider",
  opts = {},
  keys = {
    {
      "w",
      "<cmd>lua require('spider').motion('w')<CR>",
      mode = { "n", "o", "x" },
      desc = "Move to start of next of word",
    },
    {
      "e",
      "<cmd>lua require('spider').motion('e')<CR>",
      mode = { "n", "o", "x" },
      desc = "Move to end of word",
    },
    {
      "b",
      "<cmd>lua require('spider').motion('b')<CR>",
      mode = { "n", "o", "x" },
      desc = "Move to start of previous word",
    },
  },
}
```

这个插件不会自动设置快捷键，所以我在插件配置中加入了 keys 表。这个数组不会传给插件本身，而是由 Lazy.nvim 插件管理器解析后添加到全局快捷键中。把快捷键配置和插件配置放在一起是个好习惯，这样所有相关配置都在同一个地方。

我看了 nvim-spider 的说明文档后，觉得它的默认选项就挺好的，所以就传了个空的 opts 表。

想找优质的第三方插件，最好的地方就是 github 上的 rockerBOO/awesome-neovim 仓库。这个列表维护得很好，而且（最重要的是）会定期更新，所以很少有过时或无人维护的插件。

实际上，LazyVim 已经自带了大多数最优质的插件（内置的或作为扩展的），所以你需要额外添加的插件不会太多。不过如果你遇到"要是 LazyVim 能做到..."这样的想法，答案很可能是：它已经可以做到了，相关插件就在 Awesome Neovim 仓库里。

## [5.7. 总结](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-5/#_summary_5)

在这一章中，我们学习了 LazyVim 是如何与更广泛的 Neovim 插件生态系统集成的。LazyVim 提供了合理的默认插件和配置，同时也让你能轻松地根据自己的需求进行定制。

我们了解到内置插件、额外插件和未知的第三方插件虽然处理方式略有不同，但都遵循一致的配置方法。我们还通过实例学习了如何安装一些第三方插件。

现在你已经知道了：

- 如何打开文件

- 如何配置插件

接下来我们要回到模式编辑（modal editing）的基础部分。你已经知道了：

- 如何在普通模式（Normal）和插入模式（Insert）之间切换
- 如何在代码中导航

在下一章，我们将介绍一些基本的编辑功能，这些功能模糊了"导航"和"插入文本"之间的界限。

# [第六章 基础编辑](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-6/#_basic_editing)

通过前面学习的导航快捷键，以及能够随心所欲地进入和退出插入模式，你在 Vim 中的编辑体验已经接近于传统非模态编辑器的水平了。

不过，对于一个软件开发者来说，仅仅会移动光标和插入文本是远远不够的。我们更多时候需要编辑文本：删除代码、修改代码、重构代码、移动代码。这些才是我们日常工作中最常做的事情。

当然，你可以通过移动到目标位置然后进入插入模式来完成这些操作。在插入模式下，删除键和退格键的功能和其他编辑器是一样的。但是，Vim 提供了更多高效的工具。

最棒的是，在要使用到的这些强大的编辑命令中，你其实已经掌握了大部分需要的基础知识！

## [6.1. Vim 命令的思维模型](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-6/#_the_vim_command_mental_model)

你已经学过的导航命令，比如 s、f、hjkl 和 web 等，统称为动作命令（motion commands）。它们的作用是将光标从当前位置移动到新位置。

大多数动作命令前面都可以加上数字（count），所以导航模式总是遵循 <数字><动作> 的格式。数字通常用来重复执行某个动作特定次数，但有些命令会把这个数字当作绝对值使用，比如用于"跳转到指定行"的 Shift-G。如果没有指定数字，默认值通常是 1。即使是使用标签的 Seek 命令也允许在前面加数字...虽然这个数字会被忽略！

<数字><动作> 命令在导航时很有用，到目前为止我们也只是把它用于导航。但是，如果把它和动词（verb）组合使用，就可以对光标位置和动作目标位置之间的文本进行操作。

动词总是放在最前面，所以命令结构永远是 <动词><数字><动作>。导航可以看作是"默认"动词，所以如果省略动词，光标就会移动到动作指定的位置。我们将在本章讨论几个重要的动词。

但这个模型还可以更复杂！动词前面也可以加数字。这样语法就变成了 <数字><动词><数字><动作>。不过说实话，我从来没有在一个命令中同时使用过这四个部分。通常我们要么用 <数字><动词><动作>，要么用 <动词><数字><动作>。

这个模型的好处在于，它让你可以分而治之地学习，并且能够重复利用已掌握的知识。你先学习了动作命令，然后学习了数字，现在要学习动词。将来如果你学习新的动作命令或动词，都可以把它们和已知的动词、动作组合使用，而且它们的行为方式都是可预测的。

> 很多插件都试图模仿这种策略，而且大多数都做得不错。我对 Neo-tree 主要的不满是它没有遵循 <动词><动作> 的思维模型，而 mini.files 做到了这一点。同样，有些人认为 Seek 模式违反了 Vim 的思维模型，因为在 Seek 模式中使用数字没有意义。我的观点是，Seek 模式只是超越了数字的概念，但它仍然可以和动词很好地组合，所以它仍然是一个有效的 Vim 模型。

### [6.1.1. 关于插入模式的说明](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-6/#_a_note_on_insert_mode)

和所有模型一样，这个模型也不是完美的。比如，你可以在 i、I、a 和 A 命令前面加数字，但很明显"进入插入模式"既不是动作也不是动词。

举个例子，如果你输入 5ifoo<Escape>，Neovim 会帮你插入 foofoofoofoofoo。这看起来可能用处不大，但如果你想在标题下面画一条由 80 个星号组成的分割线，用 80i*<Escape> 就非常方便！

但是，这种带数字的 i "非动作"命令不能像你学过的导航命令那样与动词组合使用。所以了解这个模型的局限性很重要。

现在你已经明白了如何将已经掌握的动作命令与动词组合来执行导航以外的操作，接下来你只需要学习一些动词就可以了。

## [6.2. 删除文本](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-6/#_deleting_text)

我之前已经预示过几次了，即使没有预示，你可能也能猜到删除文本的动词是 d。

当 <动作> 命令会将光标移动到代码中的特定位置时，d<动作> 会删除光标位置到目标位置之间的所有文本。以下是一些例子：

- dh 删除光标左边的字符
- d3w 删除三个单词
- 3dw 分三次删除一个单词
- d^ 删除从光标到行首的内容
- d2fe 删除从光标位置到光标后第二个 e 之间的所有文本（包括第二个 e）
- d2Ta 删除从光标到光标前第二个 a 之间的所有文本（不包括第二个 a）
- dsfoos 删除从当前光标位置到使用 Seek 模式查找 foo 时出现的标签 s 之间的文本。注意，Seek 模式总是跳转到你搜索的单词的开头。这意味着如果找到的 foo 在当前光标位置之后，oo 不会被删除，但 f 会被删除。但如果找到的 foo 在当前光标位置之前，foo 的所有三个字母都会被删除

如果以上任何操作让你感到困惑，可以暂时忽略 d，回顾第三章来复习这些动作命令。

所以 d 可以和你已知的所有动作命令配合使用，也可以和你还不知道的所有动作命令配合使用，甚至可以和你尚未安装的插件定义的所有动作命令配合使用。

当删除命令执行完成后，Neovim 仍然会保持在普通模式，你可以立即执行任何其他的 <动词><动作> 组合。

## [6.3. 修改文本](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-6/#_changing_text)

另一个常见的任务是编辑文本。比如替换一个单词，更正拼写，删除段落剩余部分并替换成新内容等。

这些操作可以通过组合删除动词和插入模式来完成（例如 dwi 会删除一个单词并进入插入模式）。不过，你可以使用 c 动词来节省一次按键，c 表示"修改"（change）。如果你把上面例子中的 d 都换成 c，就相当于"删除文本并立即进入插入模式"。以下是一些例子：

- ch 删除光标左边的字符并进入插入模式
- c3w 删除三个单词并进入插入模式
- 3cw 分三次删除并修改单词
- c^ 删除从光标到行首的内容并进入插入模式
- c2fe 删除从光标到第二个 e 之间的文本并进入插入模式
- c2Ta 删除从光标到前面第二个 a 之间的文本并进入插入模式
- csfoos 删除从光标到 Seek 模式找到的 foo 之间的文本并进入插入模式

这样你就可以立即输入新的文本来替换被删除的内容。当你完成编辑并按下 <Escape> 后，Neovim 会返回到普通模式。

## [6.4. 操作到当前行末](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-6/#_operating_to_end_of_the_current_line)

从光标位置删除或修改到当前行末（保留行首内容）是非常常见的操作。在源代码编辑中，这些操作的频率比你想象的要高，所以有一个专门的快捷方式。

是的，你可以使用 d$ 和 c$ 来删除或修改到行末，因为 $ 是"跳转到行末"的动作命令。这符合我们之前学习的思维模型。但是，由于这是一个如此常见的操作，你可以使用大写的 D 或 C 来"取巧"，少按一个键。

但是没有相应的"删除到行首"的快捷动词，所以你只能使用 d^ 或 d0。其中：

- ^ 是跳转到第一个非空白字符的动作
- 0 是跳转到行首第一列的动作（不管是否是空白字符）

所以总结一下：

- D = d$ （删除到行末）
- C = c$ （修改到行末）
- 删除到行首需要用 d^ 或 d0
- 修改到行首需要用 c^ 或 c0

## [6.5. 对整行进行操作](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-6/#_operating_on_entire_lines)

另一个常见的操作是修改或删除整行文本。这种操作非常频繁，以至于有专门的"整行"动作命令。这些动作通过重复动词来实现。这又是一个 vim 思维模型有点失效的地方，因为动作的解释取决于动词。

实际使用中，这意味着：

- dd 删除整行
- cc 删除整行并进入插入模式

这些命令很容易输入，所以是很好用的简写方式。

你可以将这些特殊动作与数字组合使用：

- d3d 删除三行
- 3dd 删除一行三次（这种方式打字更快，因为你不需要把手指从 d 键移开就能按两次）

是的，这两种方式的结果是一样的，但模型允许你使用其中任何一种。需要注意的是，在某些情况下，这两种格式可能会有细微的行为差异，不过在实践中我从未遇到过意外情况。

这种整行操作的设计使得处理整行文本变得非常高效，这在编程时特别有用，因为我们经常需要删除或修改完整的代码行。

## [6.6. 修改单个字符的快捷方式](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-6/#_some_shortcuts_for_modifying_individual_characters)

修改单个或特定数量字符是另一个常见操作。你可以使用 dl 删除光标下的字符，或用 4dl 删除当前字符及后面的三个字符。但是，由于这个操作非常频繁，有一个不需要动作（或者说动作是隐含的）的快捷动词：x。例如，如果你想把英式拼写改为美式拼写，可以用 x 删除 "behaviour" 中多余的 u。单个字母会被删除，然后你会回到普通模式继续操作。

x 命令可以和数字配合使用，如果你想从光标位置开始删除五个字符，只需使用 5x。

如果你需要向反方向删除（删除光标前的字符），使用大写的 X。这个命令也可以带数字，会删除光标左边指定数量的字符。我很少使用这个命令，因为需要按 Shift 键就已经是两次按键了，用 hx 或 d4h 也可以做到。

如果你想把一个字符替换成另一个字符，使用 r 命令。这个命令会短暂进入插入模式让你输入一个字符，然后立即返回普通模式。对于常见操作（拼写错误很常见，对吧？不只是我吧？）来说，这比像 cle<Escape> 这样的操作要少按很多键。r 命令也可以带数字，但行为可能不太有用：它会用同一个字母替换光标下的字符及其后面指定数量的字符。这个功能唯一可能有用的场景是当你从某处复制密码提示时，需要把密码中的所有字符都替换成 *。

另一个常见操作是删除当前行末尾的换行符。在行内任何位置使用 J（"**J**oin Lines"）命令。我经常使用这个命令。如果你需要合并多个连续的行，J 可以带数字。它通常会正确处理空白（用单个空格替换缩进），但如果你需要在不修改空白的情况下连接行，使用两字符动词 gJ。

总结一下：

- x：删除光标下的字符
- X：删除光标前的字符
- r：替换光标下的字符
- J：连接行（处理空白）
- gJ：连接行（保留空白）

## [6.7. 大小写操作](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-6/#_manipulating_case)

如果你需要将字符或一系列字符转换为大写，使用动词 gU（第二个字符是大写 U）加上任何标准导航动作。我觉得这个动词有点令人困惑，因为 g 通常用于 Go To（跳转）动作。但在这里（如同上面的 gJ），它是一个动词。

你可以把它理解为"跳转并转换为大写"，其中 U 是 Uppercase 的缩写。

相反的操作是使用小写的 gu 加动作，可以将光标位置到动作目标之间的所有文本转换为小写。这个设计虽然有点奇怪，但符合 Vim 的惯例：gu 表示一个动作，而 gU 表示相同的动作但更"大"。

重复命令 gUgU 和 gugu 与其他重复动词（dd、yy、cc）类似，将大/小写转换应用到整行。不过这个按键序列相当烦人，所以使用可视模式（我们将在第 8 章介绍）可能更好 - 用 V 选择一行，然后使用可视模式的 U 或 u 命令。

我觉得这些命令用处不大。我更常用 ~ 命令，它可以反转光标下字符的大小写。

> 如果你经常需要进行大小写转换工作，可以看看 coerce.nvim 插件。它没有包含在 LazyVim 的额外功能中，所以你需要自己配置，但可能值得花这个功夫。

总结命令：

- gU{动作}：转换为大写
- gu{动作}：转换为小写
- gUgU 或 gugu：转换整行
- ~：反转当前字符大小写
- 可视模式：V + U/u

## [6.8. 重复命令](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-6/#_repeating_commands)

LazyVim 没有多光标模式。虽然有支持多光标的插件，但根据我的经验，它们工作得并不是很好。Neovim 开发者已经将多光标功能列入了他们的开发计划，所以我希望他们能开发出一个很好地融入 Vim 思维模型的范式。

> （ethan）我觉得 [vim-visual-multi](https://github.com/mg979/vim-visual-multi) 挺好的

在此期间，Neovim 提供了几种不同的工具来在代码中的多个位置执行操作。我们这里会介绍基本的重复操作，其他有用的技巧将在后面的章节中介绍。

当你执行任何动词后，你可以导航到文档中的另一个位置，然后用一个键重复那个动词：.（这是一个句点，在这个上下文中通常被称为"点重复"）。

这突显了为什么 d 和 c 需要是独立的动词，而不是使用类似 d<motion>i 这样的组合。当你使用 c 时，删除动作和你插入的文本都会被记住，所以你可以用 . 命令重复整个更改。例如，如果你想把所有名为 i 的变量替换成更好的名字 index，你可以跳到第一个 i 处，输入 clindex<Escape> 来"将一个字符改为 index"。然后你可以使用导航命令去到下一个 i。现在只需输入 . 来重复这个更改，然后继续找下一个实例。

像动作和动词一样，. 命令也可以带数字。不过，. 的数字使用有一些细微差别。它不是简单地重复命令 <count> 次，而是会替换被重复命令的数字。

这意味着如果你使用动词 3dd 删除三行，然后下一个操作是 2.（"2点"），第二个操作将删除两行，而不是六行。

关键点：

- . 命令可以重复上一个修改操作
- 特别适合配合 c（change）命令使用
- 数字会替换原命令的数字，而不是重复次数
- 这是在没有多光标模式下的一个重要替代方案

## [6.9. 录制命令](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-6/#_recording_commands)

Vim 的命令录制和回放系统非常强大。你可以轻松地录制任意序列的导航、编辑和插入命令，然后在任何想要的位置按需重复该序列。

要开始录制，按 qq。抱歉，我没有什么帮助记忆 q 命令的方法。我感觉这可能只是因为它是键盘上最后一个可用的键！

之后，输入你想要录制的任何导航、编辑和插入命令序列。删除单词、插入文本、更改文本、搜索单词（不要使用 Seek 模式，因为回放机制不知道要跳转到哪个标签）。实际上，在 Vim 中你能做的几乎任何事情（甚至包括 : 命令）都可以被录制并在之后重放。

当你完成录制时，只需再次按 q。录制的内容就会被存储起来，随时可以重放。

主要要点：

- 使用 qq 开始录制
- 可以录制几乎所有 Vim 操作
  - 导航命令
  - 编辑命令
  - 插入命令
  - 搜索命令（除了 Seek 模式）
  - 冒号命令
- 再次按 q 结束录制
- 录制的命令可以随时重放

### [6.9.1. 追加录制](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-6/#_appending_to_a_recording)

如果你完成部分录制后，发现需要一些额外信息或在完成录制前需要进行编辑，你可以像平常一样用 q 停止录制，然后做你需要做的事情。

当你准备继续录制时，使用 qQ 进入追加录制模式。这里的主要提示是，你需要确保光标位置在一个合适的位置，使得合并后的录制内容是有意义的。这通常意味着要回到停止录制时的位置，当然这也可能取决于你在此期间做了什么改动。

### [6.9.2. 回放录制](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-6/#_playing_back_a_recording)

回放最近保存的录制内容最简单和最快的方法是使用大写的 Q。

> 可以使用寄存器（这是一个愚蠢的名字，源自人类汇编编程的黑暗时期，用于表示存储位置）同时存储和替换多个录制。我们将在第 8 章详细讨论寄存器。

关键点：

- 追加录制
  - 使用 qQ 继续录制
  - 需要注意光标位置的合适性
  - 确保合并后的录制内容有意义
- 回放录制
  - Q 快速回放最近的录制
  - 可以使用寄存器存储多个录制
  - 寄存器相关内容将在第 8 章详细介绍

## [6.10. 撤销和重做](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-6/#_undo_and_redo)

显然，这些是整本书中最重要的操作！使用 u 键来撤销你最近的更改。注意，"最近的更改"可能包含相当多的文本，特别是如果你长时间没有退出插入模式。例如，我在一次插入会话中写完了整个段落。如果我按 u，整个段落都会消失。

不过没关系，因为我可以用 Control-r 重做。像大多数开发者一样，我经常使用这两个功能。（你知道吗？在打字机时代，秘书们的打字测试必须达到 100% 的准确率，因为那时候没有退格键或删除键。）

Neovim 实际上在跟踪你的整个历史记录方面做得非常出色，而不仅仅是最近的一系列更改。所以如果你做了一系列更改到达状态 B，然后撤销回到状态 A，之后又做了一系列更改到达状态 C，你仍然可以回到状态 B（即：从 C 状态撤销回到 A 状态，然后重新应用 B 的更改回到 B 状态）。

这有点像 git 分支的概念，只不过你的历史记录是针对每个按键自动跟踪的。不过，使用原始的 Neovim 命令处理撤销历史的分支可能会感觉很笨拙（如果你够勇敢的话，可以阅读 :help undo-branches）。相反，我建议配置和安装 undotree 插件。

99.9% 的情况下，u 和 Control-r 就足够了，但在剩下的 0.1% 的情况下，undotree 可能会成为救星。

## [6.11. 总结](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-6/#_summary_6)

在本章中，我们扩展了对 Vim 思维模型的理解，并介绍了几个可以与我们已经熟悉的导航动作相结合的动词。

我们讨论了各种其他编辑命令，然后介绍了如何使用 . 和命令录制来重复操作。最后，我们介绍了撤销和重做功能。

在下一章中，我们将学习文本对象以及 Vim 思维模型中与操作符待决模式（operator-pending mode）相关的一些细微差别。这些结合在一起，使我们能够非常快速地对各种代码结构执行操作。

本章要点：

- 扩展了 Vim 思维模型的理解
- 学习了新的编辑动词命令
- 介绍了各种编辑命令
- 学习了使用 . 重复命令
- 掌握了命令录制功能
- 了解了撤销（u）和重做（Control-r）
- 为下一章的文本对象和操作符待决模式做准备

# [第七章：对象和操作符待决模式](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-7/#_objects_and_operator_pending_mode)

我们之前学习的导航和移动命令固然重要，但 Neovim 还提供了更多高级的移动命令，可以大大提升你的编辑效率。LazyVim 通过各种插件进一步扩展了这些移动命令，带来了更强大的导航功能。

比如，当你在编辑普通文本而不是源代码时，按句子和段落进行导航就会很有用。这里所说的"句子"，就是指以句号(.)、问号(?)或感叹号(!)结尾，并且后面跟着空白字符的内容。

说实话，这些句子相关的快捷键对我来说是最难记住的。因为用得不够频繁，所以还没有形成肌肉记忆，而且也没有一个好记的助记方法。

听起来很神秘是不是？接下来要说的内容请特别注意，因为很容易就会忘记。在普通模式下，要向前移动一个句子（移动到句子结束标点符号后的空白字符之后），按 ) （右括号）。要移动到当前句子的开头，使用 (（左括号）。重复按括号可以在句子之间移动，如果想一次移动多个句子，可以在按键前加上数字。

我其实不太喜欢用 ( 这个命令，因为按理说它应该是用来移动到括号的位置才对！但事实并非如此，它是用来在句子之间移动的。由于在日常软件开发中，句号、感叹号和问号很少表示"句子"的结束，所以我平时用得不多，只有在写书的时候才会经常用到（虽然我一直告诉自己不要再接写书的活了，但总是控制不住）。

不过，我倒是经常使用段落移动命令。在这里，"段落"指的是两个空行之间的所有内容。这个概念在编程环境中很实用，因为大多数开发者都会用空行来分隔逻辑相关的代码块。使用大括号 { 和 } 可以在段落之间上下移动。如果需要一次跳过多个段落，和其他命令一样，可以在按键前加上数字。

同样，你可能会觉得 { 应该是用来跳转到花括号的，但它实际上是用来跳转到空行的，这一点确实有点让人困惑。不过一旦习惯了，你可能会经常用到它。

## [7.1 Unimpaired（成对）模式](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-7/#_unimpaired_mode)

LazyVim 提供了一系列可以通过**方括号**访问的移动命令。完全掌握这些命令需要一些时间，但好在你只需按一下 [ 或 ] 就能调出命令菜单。和句子、段落移动命令类似，方括号命令也允许你移动到上一个或下一个"某物"，具体是什么取决于你在方括号后面按的键。

这些成对的导航技巧通常被称为"Unimpaired（成对）模式"，这个名字来源于著名的 Vim 插件作者 Tim Pope 开发的一个基础插件 [vim-unimpaired](https://github.com/tpope/vim-unimpaired)。虽然 LazyVim 没有直接使用这个插件，但保留了这个插件的核心理念（用 [ 和 ] 作为前缀，提供许多成对的操作）。

当你输入 ] 并暂停等待菜单时，会看到如下选项：

<img src="mymedia\unimpaired-menu-dark.png" alt="unimpaired menu dark" style="zoom:50%;" />

这些选项并非都与导航相关，其中有一个选项是因为我启用了相应的 Lazy Extra 才会显示。我们这里先介绍与移动相关的命令，其他的会在后面的章节中详细讲解。

首先，用于处理 (、< 和 { 的命令比看起来要复杂得多。它们并不是简单地跳转到下一个（如果你用了 ]）或上一个（如果你用了 [）括号、尖括号或花括号。如果你只想这样做，直接用 f( 或 F( 就可以了。

相反，这些命令会跳转到下一个未匹配的括号、尖括号或花括号。这意味着像 [( 或 ]} 这样的按键实际上是"跳出"的意思。所以如果你在一个被 {} 包围的代码块中间，无论这个代码块内部有多少其他用花括号分隔的代码块，你都可以用 ]} 轻松跳到当前块的结尾，或用 [{ 跳到开头。这在各种编程场景中都很有用，所以值得花时间去熟悉它。

例如，考虑如下代码：

```python
def outer_function() {
    if (condition) {
        for (i = 0; i < 10; i++) {
            print("hello") ▊    # 光标1
        } ▊    # 光标2
    }
}
```

在光标 1 的情况中：当你按 [{ 时，光标会向上跳到一个未匹配的 { 中，即 "for (i = 0; i < 10; i++) **{**" 中的 { 处。

在光标 2 的情况中：当你按 [{ 时，光标会向上跳到一个未匹配的 { 中，即 "if (condition) **{**" 中的 { 处，而不是 "for (i = 0; i < 10; i++) **{**" 中的 { 处。

作为快捷方式，你也可以使用 [% 和 ]%，其中 % 键基本上就是"当前包围我的任何括号"的占位符。它们会跳转到当前所在的括号、花括号、尖括号或方括号的开头或结尾。

有一点很重要，和其他括号不同，[[ 和 ]] 并不会从方括号中跳出，所以如果你需要跳出方括号，使用 [% 和 ]% 是唯一的选择。

> （ethan）基于以上规则：
>
> - 像：[}、]{ 这样的跳转命令是没有意义，不会跳转的。
> - 当光标不在任何包围对的内部，基于方括号的包围对跳转也是没有意义，不会跳转的。

### [7.1.1 按引用跳转](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-7/#_jump_by_reference)

你可能会认为 [[ 和 ]] 是用来跳出方括号的，但实际上这两个容易输入的组合键被保留用于一个更常用的操作：跳转到光标下变量的其他引用处（在同一文件中）。

这个功能通常依赖于当前编程语言的语言服务器，所以比简单的搜索要智能得多。它只会跳转到该函数或变量的实际使用位置，而不会跳转到其他变量、类型或注释中恰好包含这个单词的位置（这是搜索操作可能会发生的情况）。

> （ethan）实际试下来，感觉这个功能更多的是依赖于treesitter？因为他只能在单文件中跳转（不同于基于 lsp 的 References，可以在整个项目中跳转）。

> 当你移动光标时，LazyVim 会自动高亮文件中该变量的其他实例，这样你就能轻松看到 ]] 或 [[ 会将光标移动到哪里。
>

### [7.1.2 按语言特性跳转](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-7/#_jump_by_language_features)

[c、]c、[f、]f、[m 和 ]m 这些按键绑定允许你通过跳转到上一个或下一个类/类型定义、函数定义或方法定义来在源代码文件中导航。这些功能的实用性在一定程度上取决于你使用的编程语言以及该语言的语言服务配置方式，但在常用语言中都能很好地工作。

默认情况下，这些按键绑定都会跳转到上一个或下一个类/函数/方法的开头。如果你想跳转到结尾，只需要加上 **Shift** 键：[C、]C、[F、]F、[M 和 ]M 就能带你到达那里。

注意，这些和"跳出"行为是不同的：如果你在当前编辑的函数内部有一个嵌套函数或匿名回调函数，]F 按键绑定会跳转到嵌套函数的结尾，而不是跳转到当前函数之后的那个函数的结尾。

我个人不太经常使用这些按键绑定，因为还有其他方式可以在文档中导航符号，我们稍后会讨论这些方法。但是，如果你正在编辑一个大函数，想要快速跳转到文件中的下一个函数，用 ]f 可能比计算要按多少次 j，或者用 Control-d 然后按 S 进入查找模式要快得多。

### [7.1.3 跳转到缩进结束处](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-7/#_jump_to_end_of_indention)

如果你正在处理基于缩进的代码（如 Python）或深度嵌套的基于标签的标记语言（如 HTML 和 JSX），你可能会发现 mini.indentscope 这个额外插件很有用。你可以通过访问 :LazyExtras 并搜索 indentscope 来安装它。

这个插件提供了 [i 和 ]i 这对按键绑定。

LazyVim 配置了一个名为 indent-blankline 的插件，它可以帮助你可视化文件中的缩进层级。这里有一个我最近在处理的 Svelte 组件的例子：

<img src="mymedia\indent-guides-dark.png" alt="indent guides dark" style="zoom:50%;" />

这段 Svelte 代码使用两个空格作为缩进。每个缩进层级都有一条（在我的主题中是）灰色的垂直线，帮助你直观地看到该缩进层级的起始和结束位置，而"当前"的缩进层级会用不同的颜色高亮显示。

如果启用了 mini.indentscope 插件，当你移动光标时，这些线条会有一个漂亮的动画效果。更重要的是，它添加了 [i 和 ]i 这两个 unimpaired 命令，用于跳出当前缩进层级；它会跳转到当前高亮行的顶部或底部。

我在编辑 Python 代码和 Svelte 组件时经常使用这个功能。在其他语言中，我使用这个功能的频率较低，因为 [% 和 ]% 通常能更好地帮我到达下一个目标位置。不过，即使在大量使用括号的语言中，缩进指示线的视觉反馈也非常有帮助；虽然我可能会对跳转到哪个花括号感到惊讶，但缩进指示线总是很明显的。

### [7.1.4. 跳转到诊断信息](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-7/#_jumping_to_diagnostics)

说实话，我在写代码的时候总是会引入很多错误。根据不同的编程语言，LazyVim 要么是已经预先配置好了，要么可以配置成能给我提供大量的错误反馈，这些反馈通常以波浪下划线的形式显示。

> 如果你没有看到波浪下划线，建议你回到第一章，选择一个更好的终端。 

这些波浪下划线通常是由编译器、类型检查器、代码检查工具，甚至拼写检查器（取决于编程语言）生成的。有些表示错误，有些是警告，还有一些是提示。虽然其中可能有一些干扰项，但大多数都是帮助你改进代码的机会。

由于我在写代码时特别擅长制造问题，所以我经常需要"跳转到下一个波浪线"。这些标记统称为诊断信息（diagnostics），可以使用 [d 和 ]d 在它们之间跳转。如果你只想关注错误，而忽略提示和警告，可以使用 [e 和 ]e。类似地，[w 和 ]w 这两个快捷键用于在警告之间导航。

如果你正在编辑的文件启用了拼写检查（或者你通过 <Space>us 手动启用了它），可以使用 [s 和 ]s 在拼写错误之间跳转。这一点在我刚开始写这本书时让我有点困惑，因为我原以为 ]d 会带我跳转到拼写错误的波浪下划线处，但实际上需要用 ]s。

最后，如果你在代码中使用了 TODO 或 FIXME 注释，可以使用 [t 和 ]t 在它们之间跳转。

需要注意的是，与之前大多数的 ] 和 [ 快捷键不同，诊断跳转不能与动作命令组合使用。比如，d[d 并不能删除从当前位置到最近的诊断信息之间的内容。这（可能）只是 LazyVim 在定义快捷键时的一个疏忽。

### [7.1.5. 跳转到 Git 修改](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-7/#_jumping_to_git_revisions)

这是我最喜欢的方括号组合快捷键：[h 和 ]h 允许你跳转到下一个 git "hunk"（代码块）。如果你不熟悉这个词（或者你认为这个词指的是帅哥），"git hunk" 指的是文件中那些包含了尚未暂存或提交的修改的区域。

我的很多编辑工作都涉及在一个大文件的三四个地方进行修改。例如，我可能需要在文件顶部添加一个导入语句，在文件的其他地方修改一个函数调用的参数，然后在第三个地方修改接收该参数的函数。一旦开始编辑，我可能需要在这些位置之间来回跳转。]h 和 [h 非常适合这种情况，而且我不需要记住跳转历史或添加命名标记（本质上是书签）。

更棒的是，LazyVim 会用简单的视觉标记显示文件中哪些行被修改过，这样你就能知道它会跳转到哪里。让我们看看这个截图：

<img src="mymedia\git-hunks-dark.png" alt="git hunks dark" style="zoom:50%;" />

在左侧，行号的右边，你可以看到一些标记：绿色的竖条表示我插入了两行代码，橙色的竖条表示我修改了一行，还有一个小红色箭头表示我删除了一行。（另外，在我的修改引入错误的那一行，行号左侧还显示了一个波浪线诊断标记和一个红色的圆圈带叉号的图标）。如果我把光标放在文件顶部，按三次 ]h，就可以在这三个位置之间跳转。

和诊断跳转一样，[h 和 ]h 也不能与动作命令组合使用。

## [7.2. 文本对象](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-7/#_text_objects)

将动作命令与移动命令组合使用很有用，但更常用的是将这些动作命令与文本对象结合使用。Vim 本身就带有几个常见的文本对象，比如单词、句子和括号内的内容。而 LazyVim 则添加了大量其他文本对象。

> （ethan）文本对象的引入：
>
> 1. 什么是文本对象？ 想象你在编辑一篇文章，文章中有：
>
>    - 单词
>    - 句子
>    - 段落
>    - 引号中的内容
>    - 括号中的内容 
>
>    这些都是"文本对象"，它们是**有明确边界的文本单位**。
>
> 2. 为什么需要文本对象？ 想象这些场景：
>
>    - 你要删除一个单词，但光标在单词中间
>    - 你要修改引号里的内容，但光标不在开头
>    - 你要复制整个段落，但不想手动选择
>
>    没有文本对象时，你需要：
>
>    1. 移动到目标开始位置
>    2. 选中到结束位置
>    3. 执行操作
>
>    有了文本对象后，你可以：
>
>    1. 直接告诉编辑器："删除这个单词"、"修改这个引号里的内容"、"替换这个引号里的内容及这个引号"

文本对象的语法结构是 <动作><上下文><对象>。这里的动作命令就是你之前学过的那些用于移动的命令，比如 d、c、gU 等。

<上下文> 一般只有 a 或 i。你知道，这两个按键在普通模式下都是用来进入插入模式的。但是当你已经输入了一个动作命令（比如 d 或 c）后，你其实已经不在普通模式了！

这时你处于所谓的"**操作符待决模式**"（Operator Pending Mode）。你熟悉的那些导航按键在操作符待决模式下通常也是可用的，这也是为什么你可以在动作命令后执行移动命令的真正原因。但是如果插件维护者忘记定义操作符待决模式的键位映射，就会出现可以导航但无法执行动作命令的情况。

在操作符后切换到插入模式是没有意义的，所以 a 和 i 这两个按键在这里有完全不同的含义。通常，你可以把它们理解为 "around"（周围）和 "inside"（内部）（虽然在我脑子里总是简单地把它们读作 "a" 和 "in"）。它们的区别在于：a 操作会选择 inside 所选择的所有内容，再加上一些周围的上下文，具体包含什么取决于定义的对象。

举个例子，一个常见的对象是括号：(。如果你输入命令 di(，会删除（光标所在的、或者下一个）一对匹配的括号内的所有文本。但如果你输入 da(，则会删除括号内的所有文本以及两端的 ( 和 )。

要查看 LazyVim 中的许多可能的文本对象，输入 da 并暂停。这是我看到的内容：

![operator pending dark](https://lazyvim-ambitious-devs.phillips.codes/images/book/chapter-7/operator-pending-dark.png)

接下来让我们详细介绍其中的大部分内容。

### [7.2.1. 文本对象](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-7/#_textual_objects)

**操作符** w、s、p 分别用于对整个单词（word）、句子（sentence）、段落（paragraph）执行操作，它们的定义如前所述：单词是连续的非标点符号，句子是以 .、? 或 ! 结尾的内容，段落是由两个换行符分隔的内容。

这些对象在 around 和 inside 上下文之间的区别在于是否会影响**周围的空白字符**。

例如，考虑下面这段文本，假设我的光标当前位于第二个句子中 handful 这个词中间的 | 字符处：

```tex
This snippet contains a bunch of words. There are a hand|ful of
sentences.

And two paragraphs.
```

如果我想在那个位置删除 handful 这个词，我可以输入 bde 来跳到词的开头，然后删除到词的结尾。或者我可以使用 inside word 文本对象，输入 diw。

无论哪种方式，我都会在 a 和 of 之间留下一个多余的空格，因为 diw 是在词的内部操作，不会触及周围的空白。

如果我改用 daw，它会删除这个词和周围的一个空格字符，这样之后 a 和 of 之间就会正确地只有一个空格。

还有一个 W（大写）操作符，它的含义类似于用大写 W 进行单词导航：它会删除两个空白之间的所有内容，而不是将标点符号解释为词边界。

同样，我可以在相同的光标位置使用 dis 和 das 来删除整个"There are a handful of sentences."这个句子。前者不会触及 The 之前或句号之后的任何空白，而后者会正确地处理空白。

最后，我可以用 dip 或 dap 删除整个段落。区别在于，在前一种情况下，被删除段落后的空行仍然存在，而在 around 模式下，它会删除多余的空行。

通常，当我使用 c 动作命令来更改单词、句子或段落时，我会使用 i，因为我想用其他的，需要周围带空白的内容，来替换它。但当我用 d 删除文本对象时，我会使用 a，因为我不打算替换它，所以我希望空白表现得就像那个对象从未存在过一样。

### [7.2.2. 引号和括号](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-7/#_quotes_and_brackets)

**操作符** "、'、` 用于操作被双引号、单引号或反引号包围的文本。如果你使用命令 ci"，你将在（光标所在的，或下一个）两个引号之间进入插入模式，其中字符串内的所有内容都被删除。但如果你使用 da"，它还会删除引号本身。

作为快捷方式，你可以使用字母 q 作为文本对象，LazyVim 会自动判断（光标所在的，或下一个最近的）引号是单引号、双引号还是反引号，并删除该对象。我个人不使用这个功能，但我想它可能会在处理双引号时节省一次按键。

同样，如果你想对圆括号、花括号、尖括号或方括号中包含的整个块应用动作命令，你只需输入其中一个括号字符即可。考虑这些例子：di[、da(、ci{ 或 ca<。与引号一样，i 版本会保留周围的括号，而 a 版本会删除整个内容。

选择最近的括号或圆括号类型的快捷方式是 b 对象（助记符是 "bracket"）。

这些实际上可以使用计数，所以你可以删除"第三个外围花括号"而不是"最近的外围花括号"。不过我总是记不住要把计数放在哪里！如果你的记忆力比我好，语法是在 a 或 i 之前放置计数。例如，d2a{ 会删除第二近的花括号及其内的所有内容。为了更好地理解，这里有一个可视化的例子：

```javascript
class Foo {
    function bar() {
       let obj = {fizz: 'buzz'}
    }
}
```

如果我的光标在 fizz 和 'buzz' 之间的冒号上，你可以预期以下效果：

- di{ 会删除 fizz: 'buzz' 但保留周围的花括号。
- c2i{ 会删除整个 let obj = 行，并让我的光标在定义函数体的花括号内进入插入模式。
- c2a{ 会做同样的事情，但也会删除那些花括号，所以我留下的是一个没有函数体的 function bar()。
- d3i{ 会删除整个函数，只留下一个空的 Foo 类。

你也可以删除某些标点符号之间的内容。例如，ci* 和 ca_ 在处理 Markdown 文件中标记为粗体或斜体的文本内容时很有用。

如果你想操作整个缓冲区，使用 ag 或 ig 文本对象。所以 cag 是删除所有内容并重新开始的最快方法，而 yig 会复制缓冲区，这样你就可以把它粘贴到 pastebin 或聊天机器人中。g 可能看起来是一个奇怪的选择，但它与 gg 和 G 跳转到文件开头或结尾的事实有一个对称性。如果你需要一个助记符，可以把 yig 理解为"yank in global"（在全局中复制）。

### [7.2.3. 语言特性](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-7/#_language_features)

LazyVim 添加了一些有用的**操作符**，可以对整个函数或类定义、对象以及（在 HTML 和 JSX 中的）标签执行命令。总结如下：

- c：作用于类或类型
- f：作用于函数或方法
- o：作用于"对象"（这个助记符有点牵强），如代码块、循环或条件语句
- t：作用于 HTML 类型的标签（适用于 JSX）
- i：作用于"作用域"，本质上是一个缩进级别（仅当安装了前面提到的 mini.indentscope 额外插件时可用）

### [7.2.4. Git Hunks](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-7/#_git_hunks)

还记得我们在 Unimpaired 模式中讨论的 git hunks 吗？你可以用 h 对象对整个 hunk 进行类似的操作。所以快速撤销添加的一种方法就是输入 dih。但你可能不会经常这样做，因为有更好的方法处理 git，我们将在第 15 章中讨论。

### [7.2.5. 下一个和上一个文本对象](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-7/#_next_and_last_text_object)

如果你已经在你想要操作的对象内部，那么文本对象特性是很棒的，但 LazyVim 配置（使用一个叫做 mini.ai 的插件）使得你甚至可以操作光标位置附近的对象。

安装后，可以通过在要访问的对象前加上 l 或 n 来访问下一个和上一个文本对象。

再次考虑 Foo.bar Javascript 类：

```javascript
class Foo {
    function bar() {
       let obj = {fizz: 'buzz'}
    }
}
```

如果我的光标在 function bar 行的 { 上，我可以输入 cin{ 来删除 fizz: 'buzz' 对象的内容，并将光标放在那里进入插入模式。我可以用一个额外的 n 键来省掉其他的导航过程。我认为这是一个非常巧妙的功能，但我总是忘记它的存在...希望在这里写下它能帮助我记住！

## [7.3. 查找周围对象](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-7/#_seeking_surrounding_objects)

提供了 Seek 模式的 flash.nvim 插件还有另一个绝妙的功能：文本对象的终极解决方案。在指定动作命令后，你可以使用 S 键（不需要 i 或 a）来显示光标周围主要代码对象的成对标签。

举个例子，我们再次使用 Foo 类。我把光标放在冒号上并输入 cS。插件识别出光标周围的各种对象，并在每个对象的两端放置标签：

<img src="mymedia\seek-object-dark.png" alt="seek object dark" style="zoom:50%;" />

这个图像中的标签是绿色的，（通常）按照从"最内层"到"最外层"的字母顺序排列。与 Seek 模式的主要区别是每个标签都是成对的；有两个 a 标签，两个 b 标签，以此类推。文本对象就是这些标签之间的内容。

如果我接下来按 a（或回车，接受默认值），那么我将更改定义 obj 的花括号内的所有内容。如果我按 b，它还会替换这些花括号。按 c 将更改整个赋值语句，而 d 将更改函数的内容。按 e 也会替换花括号，f 更改整个函数定义。g 标签是类的内容，而 h 更改整个类。

当你需要编辑对象文本，而大脑不能立即映射出这个对象的类型时，这个工具就非常有用了。

### [7.3.1. 远程查找周围的对象](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-7/#_seeking_surrounding_objects_remotely)

"S" 的**操作待命模式**对于操作光标周围的对象很有用，但如果你的光标当前不在你想要选择的对象内，它就不够用了。你可以使用 s 导航到对象内部，然后用 S 选择它，但你可以通过使用 R 操作符来节省一些按键。

以"Remote"（远程）作为助记符，R 很容易使用，但很难解释。它是一个操作待命操作，所以你需要先输入一个动作命令，然后是 R（和 S 一样，不需要 i 或 a）。

此时，LazyVim 本质上处于 Seek 模式，所以你可以输入搜索字符串的几个字符来查找屏幕上任何位置的匹配项。然而，flash.nvim 不会在你搜索的字符串的任何匹配处显示单个标签，而是会自动切换到周围对象模式，并显示所有围绕匹配位置的结构的成对标签。

更妙的是，你还可以在不使用周围模式的情况下对任何类型的对象执行远程查找。在这种情况下，你需要输入一个动作命令，然后是小写的 r（它仍然表示"remote"）。这也会让你进入 Seek 模式，你可以开始输入匹配字符。单个标签（普通 Seek 模式，而不是 Surround Seek 模式）会弹出，你可以输入一个字符来临时将光标移动到该标签，就像普通 Seek 模式一样。但当你的光标到达那里时，它会自动进入操作待命模式。所以你现在可以输入任何其他操作符，如 aw 或 i(。一旦操作完成，你的光标会移回到你进入远程 Seek 模式之前的位置。

举个具体例子，命令 drAth2w 会删除从标签 h 处的"At"这个词开始的两个词，然后将光标跳回到删除开始前的位置。换句话说，它相当于命令 sAthd2w<Control-o>，这会查找到标签 h 处的"At"这个词，然后删除两个词，并使用 Control-o 跳回到你之前的历史位置。远程命令稍短一些，但这是另一个我倾向于忘记使用的功能。我的大脑在意识到"删除"模式之前就进入了"移动光标"模式，所以当我意识到本可以远程完成时，已经太晚了。

## [7.4. 修改包围对](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-7/#_operating_on_surrounding_pairs)

我们已经看到了用于操作引号或括号对内容的文本对象，但如果你想**保留内容而改变周围的配对字符**呢？

比如你想把双引号字符串 "hello world" 改成单引号的 'hello world'。或者你要把 obj.get(some_variable) 方法查找改成 obj[some_variable] 索引查找，需要把周围的圆括号改成方括号。

LazyVim 为这种操作提供了 mini.surround 插件，但默认并未安装。这是一个推荐的额外插件，如果你按照我的建议启用了所有推荐插件，你可能已经有它了。

### [7.4.1. 添加包围对](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-7/#_add_surrounding_pair)

添加包围对**动作**的默认命令是 gsa。这会将编辑器置于操作待命模式，然后你需要输入上下文（a 或 i）和文本对象（w、s、p、"、[、{ 等）来选择要包围的文本。完成对象输入后，你需要输入想要包围它的字符，比如 "、(、)。后两者的区别在于，虽然都会用括号包围文本，但 ( 会在括号内额外添加空格。

> （ethan）如果配置了下文给出的config，则 gsa 就会失效！下文中的配置项，大致可以理解为：
>
> ;; = gsa
>
> ;d = gsd
>
> ;r = gsr
>
> ;f = gsf
>
> ...

这听起来可能很复杂，但看几个例子就明白了：

- gsai[( 会选择方括号内的内容（使用 i[）并在方括号内放置带空格的圆括号。所以如果你从 [foo bar] 开始输入 gsai[(，最终会得到 [( foo bar )]。
- gsai[) 做同样的事情，但不添加空格，所以同样的 [foo bar] 会变成 [(foo bar)]。
- gsaa[) 会将圆括号放在方括号外面，因为你用的是 a[ 而不是 i[。这次我们的例子变成了 ([foo bar])。
- gsa$" 会用双引号包围当前光标位置到行尾的所有文本。
- gsaSb' 会用单引号包围你在 S 操作后用标签 b 选择的文本对象。
- gsaraa3e* 会在以 a 开头的远程对象（标签为 a）后面的三个词的两端添加星号。

> （ethan）助记：
>
> - 可以理解为：<动作><上下文><对象><拓展>。gsa、gsd、gsr 或者符号 ;;、;d、;r 表示 <动作>，i、a 表示 <上下文>，[ 表示 <对象>，( 表示拓展。
> - 或者把 [(、["这种，当作**包围对-对象**，不过需要配合gsa、gsd、gsr这样的特定**动作**。

根据上下文，可能需要输入很多字符，但通常比独立导航到并更改配对的每一端要少按键。

### [7.4.2. 删除包围对](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-7/#_delete_surrounding_pair)

删除配对更简单，因为你不需要指定文本对象。只需使用 gsd 后跟你想要删除的配对的指示符。

所以如果你想删除光标周围的 []，可以使用 gsd[。

如果你想删除深度嵌套的元素，你需要在 gsd 命令前加上计数。所以使用 2gsd{ 来删除当前光标位置外的第二组花括号。例如，如果你的光标在字符串 {abc {def}} 中的 def 内，输入 2gsd{ 会得到 abc {def}，保留了围绕 def 的"内部"花括号，但删除了围绕整体的第二组外部花括号。

### [7.4.3. 替换包围对](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-7/#_replace_surrounding_pair)

替换类似于删除，只是命令是 gsr，并且在输入现有字符后需要输入你想要替换成的字符。

所以如果你有文本 "hello world" 且光标在其中，你可以使用 gsr"' 将双引号改为单引号：'hello world'。

### [7.4.4. 导航包围字符](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-7/#_navigate_surrounding_characters)

对包围对或其整个内容执行操作很方便，但有时你只想将光标移动到配对的开始或结束处。你通常可以使用 Seek 模式、Find 模式或 Unimpaired 模式命令（ 比如 **[(** ）来做这件事，但如果你需要的话，还有其他更语法偏向的命令。

最简单的一个已经内置在 Vim 中很长时间了的命令。如果你的光标当前在括号、方括号或花括号对的开始或结束字符上，只需按 % 就可以跳转到配对的另一端。如果你不在配对的括号上，在 Normal 模式中使用 %，它会跳转到最近的包围配对对象。不过这只适用于括号，所以不支持引号等任意配对。

mini.pairs 插件带有 gsf 和 gsF 键绑定，可用于将光标移动到相关字符。我不使用这些，因为 mini.ai 插件使用 g[ 和 g] 快捷键提供了类似的功能。这些快捷键都需要后面跟一个字符类型，例如 g[( 会跳回到最近的包围开括号，g]] 会跳到最近的闭方括号。如果你给它一个计数，它会跳出那么多层包围对。

### [7.4.5. 高亮包围字符](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-7/#_highlighting_surrounding_characters)

如果你只需要检查包围字符在哪里，你可以使用类似 gsh( 的命令，其中 h 表示"highlight"（高亮）。这有时可以用作删除或替换操作的预演，特别是在使用计数时，可以让你确认你要操作的确实是你想要的配对。

### [7.4.6. 额外功能：XML 或 HTML 标签](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-7/#_bonus_xml_or_html_tags)

mini.surround 插件主要用于处理字符对，但它也可以操作类似 html 的标签。

假设你有一段文本，想用 p 标签包围它。可以使用组合命令 gsaapt。即： gsa 表示"添加包围"，后跟 ap 表示"围绕 + 段落"。意思是，我们要在段落周围添加一些东西，不是引号不是括号，而是一个 t 标记。

mini.surround 会理解你想添加一个标签，并弹出一个小提示窗口来输入你想添加的标签。输入 p 作为你想创建的标签。你不需要尖括号；只需要标签名：

<img src="mymedia\surround-tag-dark.png" alt="surround tag dark" style="zoom:50%;" />

如果你想添加的标签有属性，你可以在提示中添加它们。mini.surround 足够智能，知道属性只放在开始标签上。

<img src="mymedia\surround-tag-attrs-dark.png" alt="surround tag attrs dark" style="zoom:50%;" />

### [7.4.7. 修改键绑定](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-7/#_modifying_the_keybindings)

我非常喜欢 mini.surround 的行为。我经常使用它。用得太多以至于很快就厌倦了重复输入 gs。我决定用 ; 替换 gs，这样我可以输入 ;d 或 ;r 而不是 gsd 或 gsr。对于添加包围，我决定利用双击按键容易输入的特点，所以我用 ;; 代替 gsa 或者 ;a。

为了让这正常工作，我还必须修改 flash.nvim 的配置来移除 ; 命令。（默认情况下，; 键可以用作 f 和 t 键的 "查找下一个" 行为，但由于 flash 的设计方式，你不需要单独的键入 ; 命令，只需再次按 f 或 t 即可）。

如果你想和我做同样的事，只需在 config/plugins 目录下创建一个新的 Lua 文件，名字随意（我的是 extend-mini-surround.lua）。

文件内容如下：

```lua
return {
  {
    "echasnovski/mini.surround",
    opts = {
      mappings = {
        add = ";;",
        delete = ";d",
        find = ";f",
        find_left = ";F",
        highlight = ";h",
        replace = ";r",
        update_n_lines = ";n",
      },
    },
  },

  {
    "folke/flash.nvim",
    opts = {
      modes = {
        char = {
          keys = { "f", "F", "t", "T" },
        },
      },
    },
  },
}
```

由于我们要修改两个插件，我在外层 Lua 表中放了两个 Lua 表，Lazy.nvim 足够智能，能将其解析为多个插件定义。第一个将映射传递给传入 mini.surround 的 opts。这些将替换 LazyVim 为该表定义的默认键绑定（以 gs 开头的那些）。

第二个定义也传递了一个自定义的 opts 表。它用一个只定义 f、F、t 和 T 的新表替换了包含 ; 和 , 的默认键。

> 如果我知道 ; 被 flash.nvim 重新绑定，我就可以通过阅读 LazyVim 网站上的 flash.nvim 配置并查看需要覆盖什么来找到这个解决方案。但是我不知道 ; 在哪里被定义！最后不得不在 LazyVim GitHub Discussions 上寻求帮助。那里的人真的很乐于助人，如果你有任何问题，我鼓励你来打个招呼。

## [7.5. 总结](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-7/#_summary_7)

本章我们学习了一些由 LazyVim 通过重新实现 Unimpaired 模式提供的高级代码移动技术。然后我们了解了什么是文本对象，并快速学习了 LazyVim 提供的众多文本对象。

主要内容包括：

1. **Unimpaired 模式**
   - 提供了一系列成对的命令来进行代码导航和操作
   - 使用 [ 和 ] 作为前缀的各种命令
2. **文本对象**
   - 理解了文本对象的概念
   - 学习了如何使用 i 和 a 来操作文本对象内部或包含边界
   - 掌握了 LazyVim 提供的各种文本对象类型
3. **S 动作及其变体**
   - S 动作可以即时选择文本对象
   - R（远程）变体用于操作光标之外的对象
   - r 变体提供了不使用周围模式的远程查找
4. **包围对操作**
   - 使用 mini.surround 插件处理配对字符
   - 学习了添加（gsa）、删除（gsd）和替换（gsr）包围对的操作
   - 掌握了处理 HTML/XML 标签的特殊功能
   - 了解了如何自定义键绑定来优化工作流程

下一章我们将学习：

- 剪贴板交互
- 寄存器的使用
- 用于文本选择的全新可视模式

这些功能将进一步提升我们的文本编辑效率。

# [第八章：剪贴板、寄存器和可视化模式](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-8/#_clipboard_registers_and_selection)

Vim 的复制粘贴功能比你在其他编辑器中使用的操作系统剪贴板要更早，也更强大。值得庆幸的是，LazyVim 的配置已经自动设置好了 Neovim 的剪贴板系统，可以直接与操作系统的剪贴板协同工作。

实际上，你已经知道如何将文本剪切到系统剪贴板了：只需要使用删除就可以。

没错，每当你使用 d 或 c 命令时，被删除的文本会自动剪切到剪贴板中。这通常很方便，但有时也会有点烦人。在本章后面，我会向你展示如何避免保存被删除的文本的解决方法。

## [8.1 粘贴文本](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-8/#_pasting_text)

在 Vim 中，使用我在第一章中简单提到过的 p 命令进行粘贴文本（通常称为"putting"）。在普通模式下，单个 p 命令会将系统剪贴板中的内容放置在当前光标位置。这通常是你最近删除的文本，但也可以是从浏览器复制的 URL、从邮件复制的文本或其他任何系统剪贴板对象。

插入文本的位置可能会有点出人意料，但通常都能符合你的预期。一般情况下，如果你删除了几个单词或不是整行的字符串，它会直接插入到当前光标位置之后。但是，如果你使用了像 dd 或 cc 这样操作整行的命令，文本会被放置在下一行。可以节省一些移动导航的按键操作，这在代码编辑中是很常见的任务。

p 命令可以与数字配合使用，所以在那些不太可能发生的场景下，比如你想连续粘贴剪贴板中内容的 5 个副本，你可以使用 5p。

当你使用 p 粘贴时，光标会保持在原位，文本会插入到光标之后。如果你想在当前光标位置之前粘贴文本，可以使用大写的 P，这个转换动作可以理解为"在相反方向执行 p"。与 p 一样，文本会直接插入到光标位置之前，除非是像 dd 这样的整行编辑，这种情况下文本会被放置在上一行。

如果你已经在插入模式下，需要粘贴内容并继续输入，可以使用 Control-r 命令，然后按 + 键。r 可能不太好记，但它代表"register"（寄存器）。我们稍后会详细讨论寄存器的概念。

## [8.2 复制文本](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-8/#_copying_text)

复制文本需要一个新的命令：y。它的行为与 d 和 c 类似，但不会修改缓冲区内容；它只是复制由 y 后面的动作或文本对象定义的文本。

你可能会问："为什么用 y 呢"，因为它代表"yank"，这是 Vim 中"复制"的专业术语。我不知道为什么 vi 要叫它"yank"，但我猜这可能是一个反向缩写（根据缩写反向推出全称）。原作者们可能注意到键盘上的 y 键当时还没有被使用，就决定想出一个与之匹配的词。当时剪贴板或复制/粘贴的概念还没有标准化，所以他们可以自由使用任何合适的术语。

y 命令可以与你已经熟悉的所有动作和文本对象配合使用。它在配合 r 和 R 远程查找命令时特别有用。如果你需要从编辑器的其他位置（甚至是不同的窗口）复制文本到当前光标位置，yR<search><label>p 是最快的方法，而且不会在历史记录中添加不必要的跳转。

yy、Y 命令分别会：复制整行、从光标到行尾的内容，这与删除和修改文本时的对应命令类似。

LazyVim 会短暂高亮显示你复制的文本，这样你就能清楚地知道你的动作命令是否复制了正确的内容。

## [8.3 先选择文本](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-8/#_selecting_text_first)

到目前为止，你的 Vim 编辑体验还没有涉及到选择文本的概念。是不是觉得很奇怪？我们已经讲了 8 章了！在普通的文字处理器和类似 VS Code 的文本编辑器中，你必须先选择文本，然后才能执行删除、复制、剪切或修改等操作。考虑到在那些编辑器中选择文本有多么麻烦（你必须使用鼠标，或者使用 Shift 键加光标移动的组合，还要用额外的修饰键来进行更大范围的移动），真是让人惊讶他们是怎么完成工作的！

在 Vim 的世界里，你通常是先执行动作命令，然后用文本动作或对象来隐式选择要操作的文本。这通常是最有效的方式，但在某些情况下，先高亮显示文本再操作会更方便。

这就是可视模式（Visual mode）的用武之地。可视模式是 Vim 的一个主要模式，就像普通模式和插入模式一样。从技术上讲，可视模式有三个子模式。我们先从"字符可视模式"开始，稍后再详细介绍其他两个。

> 你可能会认为先选择文本更有意义，这样你就能看到要操作的内容。两个较新的编辑器 Kakoune 和 Helix 正在尝试这种模式。它们很酷，但我发现"先选择文本"的模式有点令人失望。编辑器无法判断任何给定的移动是要移动选区还是要扩展选区，所以你最终需要额外的按键来告诉它要做扩展。这样一来，就和在 Neovim 中按 v 进入可视模式没什么区别了。在使用 Helix 几个月后，我发现它实际上需要比 Neovim 按下更多的按键操作，所以我又换回了 Neovim。

要进入字符可视模式，在普通模式中使用 v 命令即可（你也可以像其他普通编辑器那样，通过鼠标点击并滑动来进入可视模式）。然后使用你在普通模式下习惯的大多数移动命令来移动光标。之所以说"大多数"，是因为可视模式的键位映射独立于普通模式（和插入模式），有时插件可能会忽略为两种模式都设置键位映射。不过，LazyVim 在键位映射方面做得很好，所以你很少会遇到意外情况。

一旦在可视模式下选择了文本，你可以使用平常用于删除、修改或复制的命令。不同之处在于，这些命令会立即作用于选区，而不需要额外的移动命令。你甚至可以使用像 x（与 d 作用相同）这样的单字符命令，或 r 这样的单字符命令来用相同的字符替换所有选中的字符。完成命令后，编辑器会自动切换回普通模式。你也可以使用 Escape 键或再次按 v 来退出可视模式而不执行任何操作。

你可以暂时退出可视模式而不完全失去选区。在普通模式下，使用 gv（"go to last visual selection"）命令可以返回到之前的选区。如果你正在执行一个可视操作，但突然意识到需要查找什么东西、进行编辑，或从文件其他地方复制内容，然后再回到选区时，这个功能就很有用。

在进入 v（字符可视模式）后，使用 o 命令（代表"other end"）可以将光标移动到选区的另一端。这在这种场景中很有用：选择了一段文本后，但突然发现选区的另一端还有一些内容也需要被选择。由于不能从可视模式直接进入插入模式，所以 o 命令被重新用于这个目的。

### [8.3.1 行可视模式](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-8/#_line_wise_visual_mode)

v 命令对于精细的选择很有用，但如果你知道你的选择将在行边界开始和结束，你可以使用（大写的）V 来进入行可视模式。现在无论你将光标移动到哪里，光标所在的整行都会被选中。

除了选择整行外，行可视模式的主要区别在于，当你使用操作剪贴板的命令时（包括 d、c 和 y），这些行会以行模式被剪切或复制。当你之后粘贴它们时，它们会出现在下一行或上一行，而不是直接出现在光标之后。

### [8.3.2 块可视模式](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-8/#_block_wise_visual_mode)

块可视模式是 Vim 独有的一个很棒的功能。它允许你以可视方式进行选择和操作：在垂直方向上连续、但在水平方向上不连续的文本块。例如，我在下面的截图中选择了四行中每行的几个字符：

<img src="mymedia\visual-block-dark.png" alt="visual block dark" style="zoom:50%;" />

要进入块可视模式，可以使用 Control-v 命令。

在普通文本中，块可视模式可能看起来不是很有用，但当你需要在 csv 文件或 markdown 表格中剪切和粘贴表格数据列时，它就很方便了。我不经常使用这个功能，但当我需要它时，我觉得没有其他方法能如此高效地完成我需要的操作。

> 如果你使用 Control-v + $，你会得到块可视模式的一个小变体，其中选区会延伸到块中每一行的末尾。当你需要选区延伸到行尾时，这个功能很有用。

块可视模式也可以用作多光标的（不太完美的）替代方案。如果你在选择可视块后使用 I 或 A 命令，然后输入一些文本并按 Escape，你输入的文本会被复制到可视块（整列）的开头或结尾。这个功能的一个常见用途是在 Markdown 中有序列表的开头添加 * 字符，或者为需要的块注释添加边框。

## [8.4. 寄存器](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-8/#_registers)

寄存器是一种存储文本字符串以供后续使用的方式（可以参考汇编语言中寄存器的定义）。从这个角度来说，它们和剪贴板没有什么不同。实际上，Vim 中的系统剪贴板就是一个被 LazyVim 设置为默认寄存器的寄存器。

但是 Vim 有几十个其他的寄存器。这意味着你可以拥有多个自定义剪贴板，每个都包含完全不同的文本序列。这个功能非常有用，比如当你在重构代码时，需要在多个调用点粘贴几个不同代码片段的副本。

寄存器有几种不同的类型，但我们先介绍**具名寄存器**的概念。有超过二十多个具名寄存器，对应字母表中的每个字母。

要在普通模式下访问寄存器，使用 " 字符（即 Shift-<Apostrophe>）即可呼出寄存器页面，后面再跟你想访问的寄存器名称。然后输入你想对该寄存器执行的命令和动作。

所以如果我想删除三个单词并将它们存储在 a 寄存器中而不是系统剪贴板中，我会使用命令 "ad3w。"a 用于选择寄存器，d3w 是删除三个单词的普通命令。如果之后我想在其他地方粘贴同样的文本，我会使用 "ap 而不是只用 p，这样文本就会从 a 寄存器而不是默认寄存器中粘贴。

"ad<motion> 总是会用你选择的文本动作或对象替换 a 寄存器的内容。不过，你也可以使用大写的寄存器名称，通过多个删除命令来构建寄存器内容。所以 "Ad<motion> 会将你删除的文本追加到已有的 a 寄存器中。

当我需要将代码从一个函数复制到另一个函数，但源函数中有一段条件语句在目标函数中不需要时，我发现这个功能很有用。我可以使用 "ay 复制条件语句之前的文本，再使用 "Ay 追加条件语句之后的文本，然后用 "ap 一次性粘贴所有内容。

我还可以配合之前讲到的 S 命令： "byS<label> 将文本复制到 b 寄存器中。现在我可以随时使用 "ap 和 "bp 从 a 或 b 寄存器中粘贴。

如果你忘记了把文本放在哪个寄存器中，只需按 " 并等待，就会弹出一个显示所有寄存器内容的菜单。如果这个菜单不好导航，你也可以使用 <Space>s" 命令打开一个选择器对话框，允许你搜索所有寄存器。只需输入你要粘贴的寄存器中包含的几个字符，使用常用的选择器命令导航此列表，然后按 Enter 将文本粘贴到最后的光标位置。

**要在插入模式或命令模式下显示相同的菜单，使用 Ctrl-r 而不是 "。**

如果你在 <Space>s" 选择器对话框中，你会注意到除了具名的字母寄存器外还有许多其他寄存器。接下来我会逐一讨论这些寄存器。

### [8.4.1 剪贴板寄存器](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-8/#_clipboard_registers)

在 LazyVim 中，默认情况下，名为 * 和 + 的寄存器始终与默认寄存器（未命名寄存器，或者说叫 " 寄存器）相同，它们代表系统剪贴板的内容。

要理解这一点，我们需要了解一些历史：vi 有寄存器，然后操作系统开始关注剪贴板的概念，vi 用户也希望能够将内容复制到系统剪贴板。在默认（非 LazyVim）的 Vim 配置中，如果你想将文本复制到系统剪贴板，你必须在 y 之前输入 "+。在现代工作流程中，你经常需要将内容复制到浏览器、AI 聊天客户端和电子邮件中，这三个额外的按键（Shift、' 和 +）可能会变得很烦人。

除此之外，一些操作系统（通常是基于 Unix 的系统）实际上有两个操作系统剪贴板：一个用于你选择的文本的隐式剪贴板，另一个用于你通过 Control-c 显式复制的文本（在大多数程序中）。操作系统允许你通过（通常是）中键点击在其他地方粘贴它。他们和 LazyVim 中 *、+、" 寄存器的关系是：

```tex
操作系统中，鼠标选中的文本 -> * 寄存器

操作系统中，Ctrl+C 复制的文本 -> + 寄存器                  -> " 寄存器

LazyVim 中，不指定特定的寄存器时的 y、d、c等操作
```

我建议保持 LazyVim 的同步剪贴板配置，但如果你已经养成了使用传统 Vim 方式的肌肉记忆，或者你厌倦了删除的文本随意覆盖系统剪贴板，你可以禁用这个集成，让这三个寄存器按照上述方式独立运行，而不是链接在一起。要实现这一点，使用 space f c 打开 options.lua 配置文件并添加以下行：

```lua
vim.opt.clipboard = ""

# 默认配置为：
# vim.opt.clipboard = "unnamedplus,unnamed"
# 其中：
# unnamed 使 * 寄存器与默认寄存器同步
# unnamedplus 使 + 寄存器与默认寄存器同步
```

如果你不想让删除（d）或更改（c）操作覆盖剪贴板内容，可以使用"黑洞"寄存器 "_ （这是一个下划线）。所以输入 "_d<motion> 可以删除文本而不将其存储在任何寄存器中，包括系统剪贴板。

如果你想将一个寄存器的内容复制到另一个寄存器，你可以使用 ex 命令 :let @a = @b，其中 a 和 b 是你想**复制到**和**复制自**的寄存器名称。这个操作最常见的用途是将系统剪贴板的内容（可能来自其他程序）复制到另一个具名寄存器中，这样在下次执行复制操作时就不会丢失内容。例如，:let @b = @+ 会将系统剪贴板的内容复制到 b 寄存器中。

### [8.4.2 最近复制或最近插入的文本](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-8/#_the_last_yanked_or_last_inserted_text)

当你执行 y 命令而不指定目标寄存器时，文本总是会同时存储在 "0 寄存器和默认寄存器中。而且无论你执行多少次删除或更改操作来改变默认寄存器，它都会保留在 "0 中，直到下一次复制操作。

所以如果你复制了文本 abc 然后删除了文本 def，p 命令会粘贴文本 def，但你仍然可以使用 "0p 粘贴 abc。

你还可以使用 ". （句点）寄存器来粘贴最近插入的文本的副本。所以如果你在文档某处输入命令 ifoo<Escape>，然后移动到文档的其他位置并输入 ".p，它会在新的光标位置插入单词 "foo"。如果你插入了想要重复使用的文本，你可能偶尔会想要将 ". 寄存器复制到一个具名寄存器中。则可以使用前面讨论过的 :let @c = @. 命令来实现这一点。

### [8.4.3 删除寄存器（或者说编号寄存器）](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-8/#_the_delete_numbered_registers)

编号寄存器本应该非常有用，但我觉得它们相当令人困惑。寄存器 "1 到 "9 总是按升序包含你最近更改或删除的文本。所以在删除操作后，"1 中的内容会移到 "2，"2 移到 "3，以此类推，而 "9 中的内容会被丢弃。

我永远记不住最近删除的顺序，所以通常需要使用 " 菜单来查看编号寄存器的内容。以这种方式存储最近删除的文本很方便，我可以这样找到它。不过，我一般使用 yanky.nvim 插件（本章后面会讨论），所以编号寄存器对我来说用处不大。

还有一个"小删除寄存器"，可以使用 "- 访问。每当你删除任何文本时，它都会存储在编号寄存器中，但如果该文本少于一行，它也会存储在这个减号寄存器中。我很少使用这个功能，因为我的大多数更改都小于一行。

### [8.4.4 当前文件名](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-8/#_the_current_files_name)

当前正在编辑的文件名存储在 "% 寄存器中。它总是相对于编辑器的当前工作目录（通常是启动 Neovim 时所在的文件夹）。我唯一会访问这个寄存器的情况是，使用 :let @+ = @% 将文件名复制到系统剪贴板，以便能粘贴到 GUI 应用或终端中。

## [8.5 录制到寄存器](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-8/#_recording_to_registers)

还记得我在第 6 章中提到的录制命令吗？qq 开始录制，Q 回放录制内容？其实那时我说得有点过于简化了。

实际上，录制的命令是存储在具名寄存器中的。在那一章里，我随意选择了 q 寄存器，所以用 qq 来开始录制。但你同样可以使用 qa 将其存储在 a 寄存器中，或使用 qf 存储在 f 寄存器中。

qQ 命令用于"追加录制"操作，这类似于使用大写字母 "A<command> 来追加到寄存器。在这种情况下，Q 仍然是一个任意的名称。你可以使用 qA 或 qZ 等命令将录制内容追加到 q 以外的具名寄存器中。

当你在代码库中的不同位置需要进行多种不同的重复性修改时，拥有多组录制内容会非常方便。

无论使用哪个寄存器，Q 命令总是回放最近录制的命令。如果你想回放其他指定寄存器中的内容，需要使用 @ 命令，后跟寄存器名称。因此，如果你使用 qa 录制，就用 @a 回放。作为快捷方式，@@ 将始终重播你最近播放的寄存器内容（这与 Q 不同，Q 始终回放最近的录制）。

### [8.5.1 编辑录制内容](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-8/#_editing_recordings)

需要明确的是，录制的内容被放在普通寄存器中。所以如果你使用 qa 录制一系列按键到寄存器中，然后使用 "ap 粘贴该寄存器，你实际上会看到你录制的 Vim 命令列表。

如果你在录制时出错需要修改按键序列，这会很有用。录制完成后，使用例如 "a]p（指定使用 a 寄存器，在下一行粘贴并自动缩进）将其粘贴到新行。此时它就是一行普通文本，只不过恰好包含 vim 命令。你可以修改它来添加其他 Vim 命令，因为它们都只是普通的按键序列。

举个例子，假设我录制了一个命令 qadw2wdeq，它将录制到 a 寄存器（qa），内容为：删除一个词（dw），向前跳过两个词（2w），然后删除下一个词（de），最后用 q 结束录制。但录制完成后，我意识到我应该跳过 3 个词，而不是两个词。

我可以使用 "ap 来粘贴录制的内容，它会显示为：dw2wde。然后使用 f2 跳到数字 2，接着用 r3 将其替换为 3。现在我可以使用 "ayiw 将寄存器的内容替换为 dw3wde。

如果我想回放这个修改后的命令，只需像往常一样使用 @a 即可。

## [8.6 Yanky.nvim 插件](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-8/#_the_yanky_nvim_plugin)

Yanky.nvim 提供了一些优质功能，比如优化复制时的文本高亮显示，在粘贴后保持光标位置以便继续输入，但其主要特性是更好地管理你的剪贴板历史。LazyVim 还为它配置了几个新的键位绑定，使文本粘贴更加便捷。

该插件默认并未启用，但它是推荐的额外插件之一。如果你在第 5 章按照我的建议安装了所有推荐的额外插件，你可能已经启用了它。如果没有，请前往 :LazyExtras，找到 yanky.nvim 并按 x。然后重启 Neovim。

现在 Yanky 已启用，访问剪贴板历史最简单的方式是使用 <Space>p。它会弹出一个选择菜单，显示所有最近的剪贴板条目。最多可以存储一百个条目，这比编号寄存器提供的要多得多，而且它会存储你的复制内容，而不仅仅是删除和更改操作。如果你需要粘贴一些不再在剪贴板中的内容，<Space>p 可能是找到它的最快方式。

另一个非常有用的键位绑定是 [y。如果你在粘贴操作后立即使用这个命令，刚粘贴的文本将被替换为最近一次复制之前剪切或复制的文本。如果你再次按下它，它会在历史记录中再往前一步，最多可以回溯 100 步。所以如果你不确定某个删除操作在哪个编号寄存器中，或者想访问不再在 "0 寄存器中的复制文本，你可以使用 p[y[y[y... 直到找到你真正想要粘贴的文本。如果你回溯太多，可以使用 ]y 向前反向循环。

LazyVim 还创建了一些有用的键位绑定来改进文本粘贴，特别是在处理缩进方面。最有用的两个是 [p 和 ]p。

这些命令会将剪贴板中的文本粘贴到当前行的上方或下方，具体取决于你使用 [ 还是 ]。你可能认为这与前面描述的自动行级粘贴相同，但由于两个原因，它略有不同：

1. 无论使用什么命令剪切或复制剪贴板中的文本，它都会在新行上粘贴（而自动行级粘贴，需要被复制的文本是一整行）。
2. 它会自动调整新行上文本的缩进以匹配当前行的缩进。

因此，如果你要将代码移动到嵌套块中并需要更改缩进，就可以使用 ]p 而不是依赖行级粘贴。这样你就不需要在之后进行格式化了。（虽然在 LazyVim 中格式化并不难，它会在保存时自动进行）。

你还可以使用 >p、<p、>P 和 <P 在粘贴代码时自动添加或删除缩进（> 表示增加一级缩进，< 表示减少一级缩进）。

## [8.7. 总结](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-8/#_summary_8)

本章全部内容都围绕着选择和复制文本。我们学习了用于复制文本的 yank 动作，然后深入研究了可用于选择文本的各种可视模式。

接着我们了解到 Vim 有多个"剪贴板"，称为寄存器，以及如何对这些寄存器进行剪切、复制和粘贴操作。我们甚至更详细地讨论了如何使用寄存器来录制多个独立的命令序列，最后介绍了 yanky.nvim 插件，它可以让你的粘贴操作更加便捷。

在下一章中，我们将学习处理多个打开文件的各种方法，以及如何通过折叠来显示和隐藏代码。

# [第9章 缓冲区和布局](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-9/#_buffers_and_layouts)

无论你使用什么编程语言，同时处理多个文件都是不可避免的。而且经常需要在同一个文件的不同区域之间切换。

和其他代码编辑器（除了记事本）一样，Neovim 提供了一套强大的多文件处理系统。LazyVim 配置了功能强大的缓冲区、文件和窗口管理系统，虽然初看起来可能很熟悉，但实际上比普通编辑器要强大得多。

## [9.1 一些术语](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-9/#_some_terminology)

在不同的窗口管理系统中，相同的词语可能代表不同的含义。如果你阅读过 tmux、emacs、kitty、vim 和 i3 的文档，就会发现像"window"（窗口）、"pane"（面板）、"tab"（标签页）和"layout"（布局）这样的词有着多种不同的定义。

为了让你在阅读本书和大多数 Vim 及其插件的帮助文件、教程和文档时不会感到困惑，我会坚持使用 Vim 中的术语定义。不过这可能会导致你在使用其他软件时感到困惑！

下面的列表按照从最宽泛到最具体的顺序排列，但要注意这些元素之间的关系更像是一个图而不是树状结构，并不是严格的层级关系。

- **Server（服务器）**

  Neovim 可以以服务器模式运行，并且可以连接多个客户端。这意味着你可以在同一个 Neovim 实例中打开多个视图，这些视图可以来自不同的终端、GUI 软件、网页浏览器，甚至是 VS Code 扩展。通常你不需要考虑 Neovim 服务器的问题，本书后面也不会再提到它。不过现在你知道了，如果你想做一些特别的操作，比如连接到已存在的 Neovim 实例来打开提交信息，而不是在新窗口中打开 Neovim，这是完全可能的。

- **Client（客户端）**

  指你实际运行的 Neovim 应用程序。通常连接到它自己独立的服务器，但也可以配置为连接到已存在的或远程的服务器。当你输入 nvim 命令时启动的就是一个客户端，其他客户端还包括像 Neovide 或 VimR 这样的 GUI 程序。

- **Tab（标签页）**

  一个客户端可以有多个标签页。每个标签页都是一个相对独立的全屏布局。你可以在每个标签页中显示不同的缓冲区，也可以设置不同的窗口分割配置。任何时候只能看到一个标签页。这与 VS Code 和许多其他环境的设计理念很不同，在那些编辑器中，每个分割区域都有自己的一组标签。在 lazyVim 的默认配置中，可以使用 <Space><Tab><Tab> 来新建一个 Tab：

  <img src="mymedia\space-tab-tab.png" alt="space-tab-tab" style="zoom:50%;" />

- **Window（窗口）**

  也被称为"pane"（面板）或"split"（分割），窗口是屏幕上用于查看缓冲区的一个区域。每个标签页都有一个或多个窗口。通常所有窗口都是完全可见的，窗口之间不会重叠。例外情况是浮动窗口，比如当你打开选择器或 Lazy Extras 时弹出的窗口。如果缓冲区的内容无法在窗口中完全显示，窗口可以滚动。

- **Buffer（缓冲区）**

  这是 Vim 中表示当前打开并可以查看/编辑的文件的术语。一个缓冲区可以在多个窗口中显示，这意味着你可以同时查看同一个文件的不同部分，或者在多个标签页中查看同一个缓冲区。如果一个缓冲区在两个地方显示，它们的内容是完全相同的（除了滚动位置）。无论一个文件在多少个窗口或标签页中显示，**底层只会有一个对应的缓冲区**。

- **Fold（折叠）**

  在查看缓冲区时，你可以将文件的某个部分（例如函数、类或缩进层级）"折叠"成一行，从而隐藏其内容。这样你就可以同时查看同一个文件中的两个不相连的部分，而将它们之间无关的信息隐藏起来。

- **File（文件）**

  指存储在磁盘上的文件。每个缓冲区最多链接到一个文件，但也可以有不链接到任何文件的缓冲区（有时称为"scratch"缓冲区，这个术语借鉴自 Emacs）。如果缓冲区没有保存，其内容可能与磁盘上的文件内容不同。

到目前为止，在本书中你的所有操作都是在单个标签页的单个窗口中进行的，可能同时打开了多个缓冲区。现在，事情将变得更加有趣。

## [9.2. Buffers](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-9/#_buffers)

如果你使用过 Telescope、Neo-tree 或 mini.files 打开多个文件，你可能会认为缓冲区就是标签页。在下面的视图中，我打开了三个缓冲区，但当前只有一个是可见的：

<img src="mymedia\buffer-line-dark.png" alt="buffer line dark" style="zoom:50%;" />

是的，我知道它们看起来就像是其他软件中的标签页，这是因为 LazyVim 将 buffer line 配置成了 tabs 的样式。有了这个缓冲区线，你可能不会经常需要使用（真正的）Vim 标签页，因为在 Vim 中，标签页是一个完全不同的概念。

无论你打开了多少个窗口，都只有一个缓冲区线。在下面的截图中，我打开了三个缓冲区，其中两个在并排的**窗口**中可见。但编辑器顶部仍然只有一个缓冲区线。

<img src="mymedia\buffer-line-split-dark.png" alt="buffer line split dark" style="zoom:50%;" />

这意味着缓冲区是一个"全局"概念。整个 Neovim 客户端只有一个缓冲区集合，你可以从任何窗口（或标签页）访问这些缓冲区。

当然，你可以用鼠标在缓冲区线上单击来选择不同的缓冲区。但是既然 LazyVim 提供了这么多使用键盘访问缓冲区的方式，为什么要使用鼠标呢？

### [9.2.1 在打开的缓冲区之间导航](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-9/#_navigating_between_open_buffers)

切换缓冲区最简单的方法是使用 H 和 L（即 Shift-h 和 Shift-l）键。到这个时候，你应该已经非常熟悉 h 表示向左移动光标，l 表示向右移动光标了吧。如果你同时按下 shift 键，就会将当前活动窗口中显示的缓冲区切换为左侧或右侧的缓冲区。

此外，你也可以使用 [b 和 ]b 命令，它们的功能是一样的。

令人烦恼的是，这些键位绑定默认不接受计数。所以你不能用 2L 向右跳转两个标签页。这让我很困扰，因为我知道底层的 :bnext 和 :bprev 命令是支持计数的。

原来 LazyVim 将这些键位，映射到了底层插件 bufferline.nvim 提供的 BufferLineCycleNext 命令，而据我所知，这个插件不支持计数。

经过研究，我发现 BufferLineCycle* 命令的存在，是因为该插件可以对 buffer list 配置某种排序机制。但 LazyVim 并没有配置使用这个机制。所以我们可以改用传统的命令。要实现这一点，在你的插件配置文件夹中创建一个新文件，命名为（类似）extend-bufferline.lua：

```lua
return {
  "akinsho/bufferline.nvim",
  keys = {
    {
      "L",
      function()
        vim.cmd("bnext " .. vim.v.count1)
      end,
      desc = "Next buffer",
    },
    {
      "H",
      function()
        vim.cmd("bprev " .. vim.v.count1)
      end,
      desc = "Previous buffer",
    },
    {
      "]b",
      function()
        vim.cmd("bnext " .. vim.v.count1)
      end,
      desc = "Next buffer",
    },
    {
      "[b",
      function()
        vim.cmd("bprev " .. vim.v.count1)
      end,
      desc = "Previous buffer",
    },
  },
}
```

当使用计数调用键位绑定时，vim.v.count1 变量会被设置，所以可以在回调函数中访问它，并通过字符串连接（.. 运算符）传递给 Vim 命令。重启 Neovim 后，你就可以使用像 3L 这样的命令在缓冲区线上向右跳转三个缓冲区。

在缓冲区之间跳转时，另一个你会想要使用的键位绑定是 <Space><Backtick>（空格 + 反引号`）。这个命令可以在当前文件和当前窗口最近打开的文件之间切换。在 Vim 术语中，这被称为"交替文件"。

如果你打开了大量缓冲区，缓冲区线可能会变得非常拥挤。到某个时候，它会在缓冲区栏的侧边显示两个箭头，表示有"隐藏"的缓冲区。当你在缓冲区间导航时，它总是会确保活动的缓冲区是可见的。这是一个非常满的缓冲区线，左侧隐藏了四个缓冲区，右侧隐藏了两个：

<img src="mymedia\buffer-line-full-dark.png" alt="buffer line full dark" style="zoom:50%;" />

如果你打开了很多缓冲区，使用 Telescope 或 Fzf.lua（取决于你启用了哪个）来搜索打开的缓冲区可能会更容易。弹出可过滤、可滚动的缓冲区列表的键位绑定是 <Space><comma>（空格 + 逗号）。它的内容与缓冲区线完全相同，但交互方式不同。

对于有大量文件的大型项目来说，这很有用，因为使用 <Space><Space> 搜索文件可能会很困难。将你实际需要访问的相对较少的文件作为活动缓冲区打开，这样就可以在 <Space><comma> 缓冲区列表中轻松过滤。

另外，你也可以使用 Neo-tree 来导航打开的缓冲区。如果你启用 Neo-tree 侧边栏，你会看到它有一些"手风琴"式的部件（新版的 LazyVim 的 Neo-tree 可能有不一样的界面），名为 Neo-Tree、Neo-Tree Git 和 Neo-Tree Buffers。Neo-tree 有多种用于树形界面导航的源，不过 LazyVim 只预配置了这三个。

要在这些手风琴（Neo-tree 称之为"源"）之间切换，你可以用鼠标点击不同的标题，或使用 < 和 > 键（光标需要在 Neo-tree 范围内）循环切换。另外，你也可以使用 <Space>be 键序列直接显示"Buffer Explorer"。

一旦 Neo-Tree Buffers 视图可见，它看起来会像这样：

<img src="mymedia\neotree-buffers-dark.png" alt="neotree buffers dark" style="zoom:50%;" />

> 如果你打开的缓冲区不在当前的工作目录下，那它们就不会在 Neo-tree 中显示。你需要使用选择器（空格 + 逗号）来访问这些缓冲区。
>

> 如果你习惯一直打开 Neo-tree 侧边栏，你可能想禁用屏幕顶部的缓冲区线。因为它们显示的是相同的信息，没有理由在屏幕空间（这最宝贵的资源）上同时显示两者。不过要注意，这样做，同时也会禁用某些用于管理缓冲区的键位绑定。
>

### [9.2.2 关闭缓冲区](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-9/#_closing_buffers)

关闭当前缓冲区，而不关闭它当前打开的分割窗口是一个常用的操作。这个操作的键位绑定是 <Space>bd，其中 <Space>b 会弹出一个包含缓冲区相关功能的菜单，d 表示"delete"（删除）。当你这样做时，你并不是真的在删除底层文件；你只是从 Vim 的内存中删除这个缓冲区：即关闭它。

如果你当前聚焦在 Neo-tree 的缓冲区视图上，你也可以直接按 <Space>bd 关闭他。

我觉得关闭缓冲区是一个太常见的任务，不应该需要按三个键，所以我在之前定义的 extend-bufferline.lua 的 keys 数组中添加了以下内容（使用 <leader><delete> 关闭当前缓冲页）：

```lua
    {
      "<leader><delete>",
      LazyVim.ui.bufremove,
      desc = "Close current buffer"
    },
```

以下是一些其他可用于关闭缓冲区的命令：

| 键位绑定      | 描述                           | 助记符                     |
| ------------- | ------------------------------ | -------------------------- |
| <Space>bD     | 关闭缓冲区及其所在的窗口分割   | Delete 缓冲区，但更"大"    |
| <Space>bl     | 关闭标签行中右侧的所有缓冲区   | 方向导航 l                 |
| <Space>bh     | 关闭标签行中左侧的所有缓冲区   | 方向导航 h                 |
| <Space>bo     | 关闭除活动缓冲区外的所有缓冲区 | "only"（仅保留）这个缓冲区 |
| **<Space>bP** | **删除所有未固定的缓冲区**     | **"P" 是 "p" 的反义**      |

最后一个命令需要一些说明。你可以使用 <Space>bp 在任何活动缓冲区上切换"固定"状态。你会看到缓冲区名称左侧出现一个图钉图标。这个固定功能的唯一目的是在你想要使用 <Space>bP 关闭所有"不太重要的"（未固定的）文件时保持它打开。我个人不使用缓冲区固定功能，所以对我来说，<Space>bP 是"关闭所有缓冲区"的快捷方式；当我完成一个任务准备开始另一个任务时，这很有用。

你也可以通过 Telescope 或 FZF 缓冲区选择器界面（通过 <Space> + 逗号（,）打开选择器界面）关闭缓冲区。如果你使用 FZF，只需按 Control-x 就可以关闭光标所在的缓冲区。**如果你使用 Telescope，Alt-d 键位绑定应该有相同的功能。**

现在你已经了解了所有关于缓冲区的知识，让我们来讨论窗口。

## [9.3. Windows](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-9/#_windows_2)

在大多数现代环境中，"窗口"指的是操作系统级别的窗口，比如运行 Neovim 的终端。由于 Vi 早于这些环境出现，他们可以使用"窗口"这个词来指代在其他环境中现在更常被称为"面板"或"分割"的概念（例如 tmux）。

窗口管理命令都集中在 <Space>w **子模式菜单**中：

<img src="mymedia\window-menu-dark.png" alt="window menu dark" style="zoom:50%;" />

我们将在接下来的章节中介绍其中的许多命令。

> 这个菜单也可以用 Control-w 访问。从历史上看，这是 Vim 和 Neovim 默认启用的键位绑定，尽管 LazyVim 为其添加了一些额外的键位绑定。不过，<Space>w 更容易输入。
>

### [9.3.1 创建窗口分割](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-9/#_creating_window_splits)

在 LazyVim 中可以随时创建窗口。要将当前窗口"垂直"分成两半，使用 <Space>wv 键位映射。

当你创建一个分割时，新的窗口会打开另一个视图，并继承活动中的缓冲区内容，并排显示。一旦分割打开，你可以使用任何缓冲区管理命令或我们之前讨论过的打开文件的工具来切换该窗口中的缓冲区。

要在两个窗口之间创建水平分割（一个在上，一个在下），使用 <Space>ws。这个助记符不幸只是"split"（分割）。他们无法重用 <Space>wh，因为它已经用于切换窗口。

> vertical split：垂直分割
>
> horizontal split：水平分割

LazyVim 还允许你使用 <Space>| （其中 | 是 Shift-Backslash 时的垂直线）创建垂直分割，使用 <Space><->（其中 - 是减号） 创建水平分割。我觉得 <Space>ws 和 <Space>wv 更容易输入。

### [9.3.2 在打开文件时创建分割](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-9/#_creating_splits_when_opening_files)

你已经知道可以通过将光标移动到文件上并按 <Enter> 在当前窗口中从 Neo-Tree 打开文件。你还可以在 Neo-Tree 中使用 s 键在垂直分割中打开它（与在普通缓冲区中使用 <Space>ws 键创建水平分割相比，这种不对称的键位映射令人恼火）。Neo-Tree 中的 S 用于创建水平分割。

如果你使用 Telescope 或 Fzf.lua 打开文件，你将使用另一组键位绑定！要在垂直分割中打开文件，使用 Control-v 键位绑定。这在 Telescope 提示区域的插入模式和普通模式下都有效，但在 Fzf.lua 中只在插入模式下有效。要在水平分割中打开，使用 Control-x（我知道，这很奇怪，对吧？）

最后，如果你使用 mini.files，你可以使用与普通窗口相同的键位绑定（<Space>wv 和 <Space>ws）在分割中打开文件。

### [9.3.3 在窗口之间导航](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-9/#_navigating_between_windows)

你可以通过按住 control 键并配合 h、j、k、l在窗口分割之间移动光标。如果你想跳过多个窗口到达下一个窗口，它们也可以加上数字前缀。

另外，你也可以将这些键与 <Space>w 一起使用。所以 <Space>wh 为：移动到左侧的窗口。

- [智能分割](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-9/#_smart_splits)

  我强烈建议使用 mrjones2014/smart-splits.nvim 插件，它可以配置为使用相同的键位绑定在 Vim 窗口和 Kitty、Wezterm 或 Tmux 面板之间导航。看看这个截图：

  <img src="mymedia\vim-kitty-splits-dark.png" alt="vim kitty splits dark" style="zoom:50%;" />我打开了三个 Kitty 终端面板。左边的运行着 Neovim，有两个上下的窗口。右边分成了两个普通的终端面板。默认情况下，如果我想在三个 Kitty 面板之间导航，我必须使用一组键位绑定，如果我想在两个 Neovim 窗口之间导航，我必须使用另一组键位绑定。使用 smart-splits.nvim 插件，我可以使用相同的键位绑定在所有窗口之间导航，不管我的光标在哪里。

  设置 smart splits 的终端集成超出了本书的范围（GitHub 该仓库中的 README 文档应该足够了），但要在 Neovim 中配置 smart-splits 插件，可以在插件目录中创建一个文件，比如 smart-splits.lua：

  ```lua
  return {
    "mrjones2014/smart-splits.nvim",
    build = "./kitty/install-kittens.bash",
    keys = {
      {
        "<A-h>",
        function()
          require("smart-splits").move_cursor_left()
        end,
        desc = "Move to left window",
      },
      {
        "<A-l>",
        function()
          require("smart-splits").move_cursor_right()
        end,
        desc = "Move to right window",
      },
      {
        "<A-j>",
        function()
          require("smart-splits").move_cursor_down()
        end,
        desc = "Move to below window",
      },
      {
        "<A-k>",
        function()
          require("smart-splits").move_cursor_up()
        end,
        desc = "Move to above window",
      },
    },
  }
  ```

  如果你使用 WezTerm 或 Tmux，你不需要 build = 这一行，但对于这三种环境，你还需要按照插件  README 中的说明在你的 Kitty、WezTerm 或 Tmux 配置中添加一些配置。

  > （ethan）可参考我的 dotfile 里，[.tmux.conf.local](https://github.com/ifoxser/dotfiles/blob/wsl-ubuntu-24.04/.tmux.conf.local) 中关于 support smart-splits 部分的配置。

### [9.3.4 关闭窗口分割](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-9/#_closing_a_window_split)

你可以随时使用以下三个键位绑定来关闭窗口：

- <Space>wq 关闭窗口，如果它是唯一打开的窗口，则会退出（quit）Neovim。
- <Space>wc 关闭窗口，如果它是唯一打开的窗口，则会显示错误并拒绝关闭。
- <Space>wd 删除窗口。它实际上执行的操作与 <Space>wc 完全相同，但它很好记住，因为它与"删除"打开的缓冲区的 <Space>bd 对称。

在这三种情况下，缓冲区都会继续保持在缓冲区线中打开。只有窗口分割被关闭。

如果你想关闭除活动窗口外的所有分割，可以使用 <Space>wo。助记方式：表示"只（only）保留这个窗口"或"关闭其他（others）窗口"。

### [9.3.5 调整窗口大小](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-9/#_resizing_windows)

在我非传统的观点中，调整 Vim 分割大小最简单的方法是...使用鼠标。垂直分割之间有一个垂直条，你可以点击并拖动。鼠标光标不会改变以提供任何反馈表明你可以点击和拖动它，但它确实有效。水平分割也同理。

如果你坚持使用键盘：<Space>w+ 和 <Space>w- 用于增加或减少水平分割中活动窗口的高度，<Space>w> 或 <Space>w< 用于增加或减少垂直分割的宽度。它们每次的调整只有一行或一列，所以你大概会想要在这些命令前加上大于 10 的计数，或使用下面讨论的"Hydra"模式。

要将所有内容更改为"默认"大小，使用 <Space>w=，这将使所有窗口"高度和宽度相等"。

### [9.3.6 Hydra 模式](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-9/#_hydra_mode)

有时，你可能想要连续执行几个窗口命令，例如在调整窗口大小或创建包含多个分割的布局时。在这些情况下，每个命令之间都要输入 <Space>w 会很繁琐，所以 which-key 插件为我们提供了 Hydra 模式。

要进入 Hydra 窗口模式，按 <Space>w<Space>。这会将窗口菜单保持"固定"打开，这样你就可以从中发出多个按键而不会自动离开菜单。例如，<Space>w<Space>vvvs 将创建四个分割（三个垂直和一个水平）。

要离开 Hydra 模式，只需按 <Escape> 即可返回到 normal 状态。

## [9.4. Tabs](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-9/#_tabs)

LazyVim 的标签页系统很特别，跟我们平常用的不太一样。我来解释一下：

1. 首先，在 LazyVim 里，所有标签页共用同一个"打开的文件列表"（也就是缓冲区列表）。这点和其他编辑器不同，比如 VsCode 每个标签都是独立的。
2. 每个标签页可以有自己的窗口分布方式。比如：
   - 第一个标签页：你可以把窗口竖着分成三块
   - 第二个标签页：你可以把窗口分成四块，像网格一样排列
3. 在这些分割出来的窗口里（上面例子中总共有 7 个窗口），你可以：
   - 打开任何一个文件
   - 同一个文件可以在多个窗口中同时打开

所以说，Vim 的标签页更像是"布局方案"，而不是普通编辑器里的标签页概念。

LazyVim 有一个专门的标签页菜单，可以通过按 <Space><Tab> 访问：

<img src="mymedia\tab-menu-dark.png" alt="tab menu dark" style="zoom:50%;" />

### [9.4.1 新建标签页](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-9/#_tabs)

要新建标签页很简单：按 <Space><Tab><Tab> 就行。建好新标签页后，你可能会找不着它在哪！别急，看看屏幕上方缓冲区那一行的最右边，标签页都在那儿排着呢。

<img src="mymedia\tabs-in-buffer-line-dark.png" alt="tabs in buffer line dark" style="zoom:50%;" />

这个截图有两个标签页，在右侧标号为 1 和 2，旁边有一个 X。

> 左边的两个缓冲区不是标签页。我是不是强调太多次了？

不幸的是，除了数字外，标签页没有任何方式让自己看起来独特；无法预览每个标签页中哪些缓冲区是活动的或它们有什么布局。

### [9.4.2 将窗口移动至新建标签页](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-9/#_tabs)

如果你想把当前窗口移到新标签页：

- 按 <Space>wT（注意是大写的 T）
- 这个操作会：
  1. 关掉当前窗口
  2. 开个新标签页
  3. 在新标签页里显示同样的内容

> （ethan）看了原文，我也没有理解这样做有什么意义。Vim 的标签页更像是"布局方案"，而不是普通编辑器里的标签页概念，而且在 Vim 里，所有标签页共用同一个"打开的文件列表"。那么，关闭当前窗口分割，并在新标签页中创建相同的缓冲区，这有什么意义呢？后面我查了下，AI 有如下的说法：
>
> ------
>
> 想象你在写代码时的几个场景：
>
> 1. **不同的工作上下文**
>    - 标签页1：你在写主要功能
>      - 左边窗口放 controller 代码
>      - 右边窗口放 service 代码
>    - 标签页2：你在处理测试
>      - 左边是测试代码
>      - 右边是测试结果输出
> 2. **代码审查场景**
>    - 标签页1：查看整体代码结构
>      - 可能分成多个窗口对比不同文件
>    - 标签页2：深入某个具体功能
>      - 可能需要同时看这个功能的多个相关文件
> 3. **调试场景**
>    - 标签页1：代码编辑布局
>    - 标签页2：调试布局（日志、变量监视等）
>
> 所以说，标签页在 Vim 中的意义不是为了"打开多个文件"（这个用 buffer 就够了），而是为了：
>
> 1. 保存不同的工作布局
> 2. 快速切换不同的工作场景
> 3. 让工作流更有条理
>
> 这就是为什么有时你会想把一个窗口移到新标签页 - 你可能觉得："嗯，这个窗口的内容值得有个独立的工作区"，然后再在新标签页里**添加相关的分割窗口**。
>
> ------
>
> 但是，就我目前的使用场景而言，还没有找到标签页功能的实际应用需求。。。

### [9.4.3 在标签页中导航](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-9/#_tabs)

要在标签页之间导航，你可以直接点击标签页上的数字，或者使用 Vim 默认的 gt、gT 键位来前往下一个或上一个标签页。另外，LazyVim 提供的 <Space><Tab>[ 和 <Space><Tab>] 键位也可以用来切换标签页。要想直接通过数字转到特定的标签页，可以在使用 gt 时加上该数字作为计数。例如 3gt 将显示标签页 3，而不是向右跳转三个标签页。

### [9.4.4 关闭标签页](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-9/#_tabs)

有几种方式可以关闭标签页：

- 只需关闭标签页中的最后一个窗口（即使用 <Space>wq），标签页就会消失。
- <Space><tab>d 键位将关闭标签页中所有的窗口以及标签页本身。不过缓冲区还是会保持打开。
- 点击标签页栏中标签页右侧的 X 图标。

## [9.5. Sessions](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-9/#_sessions)

在经过一天艰苦的编码后，你可能打开了几个缓冲区，并且将分割和标签页配置好，所有文件都在恰当的位置。如果能把代码收起来过夜，第二天回来时，所有的这些缓冲区、标签页和分割都保持原样，那不是很好吗？

LazyVim 默认启用了内置的会话管理。只需用 <Space>qq 关闭 LazyVim 就可以了。明天早上，使用 nvim 命令打开到仪表板，按 s 就可以继续了。

如果你忘记了打开仪表板，而是使用 nvim 打开了其他的文件，你可以使用 <Space>qs 将 Neovim 恢复到你上次关闭时的状态（不过，你在此期间修改和保存的任何文件仍将保持其新内容）。

当你临时用一下 Neovim 时，可以用 <Space>qd 来关闭。这样能保护你之前保存的工作状态不被覆盖。有些情况下这会自动完成，比如：写 git commit 这样的场景时系统会自动帮你处理，不用担心会丢失之前的工作环境。

## [9.6 代码折叠](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-9/#_code_folding)

Vim 的代码折叠系统几乎过于健壮，可能是因为它多年来经历了多次"最佳实践"的迭代。LazyVim 配置了当前的最佳实践，所以，你通常只需要使用到完整的折叠命令列表中的一小部分。

如果你不熟悉这个概念，代码折叠意味着：允许你通过将整个代码段折叠成一行来隐藏它们。从视觉效果上看，这与水平分割窗口，然后在分割的上下窗口中，阅读同一文件的两个部分类似，但当你使用折叠时，只有一个缓冲区的视图可见，并且它作为一个整体滚动。

考虑这段代码：

<img src="mymedia\no-folds-dark.png" alt="no folds dark" style="zoom:50%;" />

在编辑时，假设我对截图顶部的 clearExistingTimeout 函数和底部的 addTodo 函数感兴趣，但对中间两个 save 回调的内容不感兴趣。我可以折叠这些部分，我的代码会看起来像这样：

<img src="mymedia\folds-dark.png" alt="folds dark" style="zoom:50%;" />

大多数折叠操作都可以通过在普通模式下输入 z，来访问到 z 模式菜单（我们在第 3 章处理滚动时讨论了一些 z 模式操作）。要将一段代码折叠起来，使用任何你熟悉的导航操作到达该部分，然后输入 zc，表示"**c**ollapse fold"（折叠）。

要再次打开它，使用 zo，表示"**o**pen fold"（打开折叠）。

或者，如果你只想记住一个键位绑定，za 将切换折叠，如果所在的行不是折叠行，则折叠，如果在折叠行上，则展开。

如果你在多处折叠了代码，并想快速回到没有折叠的状态，使用 zR 可以打开所有折叠。我不知道 R 应该对应什么助记符，但一位早期读者帮助指出 zr 是"reduce folding"（减少折叠），所以 zR 是"Reduce folding BUT BIGGER"（减少折叠但更大）。

你甚至可以通过折叠已经折叠过的代码来嵌套折叠。如果你想递归打开折叠，使用 zO，它将展开一个折叠以及该折叠下嵌套的任何折叠。

按照 LazyVim 的配置，你对什么被折叠没有太多控制，但它通常会根据你的光标在文档中的位置做出你期望的事情。"你期望的事情"取决于你正在使用的语言的 LSP 和 TreeSitter 语法，但我发现最好就让它自己处理，不要与它争论。

如果你发现你想要更多的代码折叠控制，我建议完整阅读 :help folding。不过很有可能，你不想要更多的折叠控制，只想让 LazyVim 为你处理它！

## [9.7. 总结](https://lazyvim-ambitious-devs.phillips.codes/course/chapter-9/#_summary_9)

在本章中，我们学习了 Vim 的缓冲区、窗口和标签页，以及它们不仅彼此之间不同，而且与许多其他窗口管理范式也不同。Vim 有与其他编辑器相同的概念，但它们有时以不同的方式混合或命名。

我们还介绍了代码折叠，用来更容易的处理大文件，还了解了会话管理，用来保存你的窗口配置并在之后回到它。当与 LazyVim 闪电般的启动时间结合时，这特别有用。当你不在编辑代码时，没有理由让你的代码编辑器保持打开消耗内存。

在下一章中，我们将深入研究 LazyVim 提供的一些出色的编程语言支持。这可以说是让 VS Code 变得惊人的一件事，但 Vim 社区已经从竞争对手那里学习，并最终超越了他们。









